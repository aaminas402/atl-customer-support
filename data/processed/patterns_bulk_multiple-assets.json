{
  "source_url": "patterns_bulk_multiple-assets.html",
  "text": "Operate on multiple assets - Developer\nSkip to content\nOperate on multiple assets at the same time\nÂ¶\nYou may also want to make changes to many assets at the same time.\nOptimize changes to many assets\nIf you need to create or update many assets it will be more efficient to do this with fewer API calls than one API call per asset. The approach outlined below allows you to bundle together these multiple actions into a single API call.\n2.0.0\n1.1.0\nFor example:\nJava\nPython\nKotlin\nRaw REST API\nAdd certificate to multiple existing assets\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\nList\n<\nAsset\n>\nassets\n=\nnew\nArrayList\n<>\n();\nassets\n.\nadd\n(\nGlossaryTerm\n// (1)\n.\nupdater\n(\n\"gsNccqJraDZqM6WyGP3ea@FzCMyPR2LxkPFgr8eNGrq\"\n,\n// (2)\n\"Example Term\"\n,\n\"b4113341-251b-4adc-81fb-2420501c30e6\"\n)\n.\ncertificateStatus\n(\nCertificateStatus\n.\nDEPRECATED\n)\n// (3)\n.\ncertificateStatusMessage\n(\n\"This asset should no longer be used.\"\n)\n.\nbuild\n());\n// (4)\nassets\n.\nadd\n(\nGlossaryTerm\n.\nupdater\n(\n\"sduw38sCas83Ca8sdf982@FzCMyPR2LxkPFgr8eNGrq\"\n,\n// (5)\n\"Another Term\"\n,\n\"b267858d-8316-4c41-a56a-6e9b840cef4a\"\n)\n.\ncertificateStatus\n(\nCertificateStatus\n.\nDEPRECATED\n)\n.\ncertificateStatusMessage\n(\n\"This asset should no longer be used.\"\n)\n.\nbuild\n());\n// (6)\nAssetMutationResponse\nresponse\n=\nclient\n// (7)\n.\nassets\n.\nsave\n(\nassets\n,\nfalse\n);\n// (8)\nassert\nresponse\n.\ngetUpdatedAssets\n().\nsize\n()\n==\n2\n// (9)\nDefine our object directly into an element of a\nList\n, rather than managing a separate object.\nUse the\nupdater()\nmethod to initialize the object with all\nnecessary attributes for updating it\n.\nDirectly chain our enrichment methods to add the certificate and message onto the\nupdater()\nmethod's result.\nCall the\nbuild()\nmethod to build the enriched object.\nUse the\nupdater()\nmethod to initialize the object for another\nasset\n.\nChain the enrichment and\nbuild()\nmethods like we did for the previous\nasset\n.\nTo optimize our update, we want to limit the number of API calls we make. If we called\nsave()\nagainst each of\nn\nassets\nindividually, we would have\nn\nAPI calls. To avoid this we use an\nAtlanClient\nthrough which to connect to the tenant.\nHere we use the client directly with a list of\nassets\nâ€” this makes 1 API call to update all\nn\nassets\nat the same time.\nThe response will include all\nn\nassets\nthat were updated.\nAdd certificate to multiple existing assets\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\nfrom\npyatlan.client.atlan\nimport\nAtlanClient\nfrom\npyatlan.model.assets\nimport\n(\nAnnouncement\n,\nAtlasGlossaryTerm\n,\nAtlasGlossaryCategory\n,\nAtlasGlossary\n,\n)\nfrom\npyatlan.model.enums\nimport\nAnnouncementType\n,\nCertificateStatus\nclient\n=\nAtlanClient\n()\nterm_1\n=\nAtlasGlossaryTerm\n.\nupdater\n(\n# (1)\nqualified_name\n=\n\"z9mfCRg6tItxcEyaJRNB3@reqKq68ZTSzuf7ezoZoGS\"\n,\nname\n=\n\"Example Term\"\n,\nglossary_guid\n=\n\"37e50bf7-abcb-4509-8155-c4894c05c9b9\"\n,\n)\nterm_1\n.\ncertificate_status\n=\nCertificateStatus\n.\nDEPRECATED\n# (2)\nterm_1\n.\ncertificate_status_message\n=\n\"This asset should no longer be used.\"\n# (3)\nterm_2\n=\nAtlasGlossaryTerm\n.\nupdater\n(\n# (4)\nqualified_name\n=\n\"2EqDFWZ6sCjbxcDNL0jFV@3Wn0W7PFCfjyKmGBZ7FLD\"\n,\nname\n=\n\"Term Test\"\n,\nglossary_guid\n=\n\"b9548564-4a2e-457a-a6fc-d7311dd39eef\"\n,\n)\nterm_2\n.\ncertificate_status\n=\nCertificateStatus\n.\nDEPRECATED\n# (5)\nterm_2\n.\ncertificate_status_message\n=\n\"This asset should no longer be used.\"\n# (6)\nresponse\n=\nclient\n.\nasset\n.\nsave\n([\nterm_1\n,\nterm_2\n])\n# (7)\nassert\nlen\n(\nresponse\n.\nassets_updated\n(\nasset_type\n=\nAtlasGlossaryTerm\n))\n==\n2\n# (8)\nUse the\nupdater()\nmethod to initialize the object with all\nnecessary attributes for updating it\n.\nSet the certificate_status.\nSet the certificate_status_message.\nUse the\nupdater()\nmethod to initialize another object with all\nnecessary attributes for updating it\n.\nSet the certificate_status.\nSet the certificate_status_message.\nTo optimize our update, we want to limit the number of API calls we make. If we called\nsave()\nagainst each of\nn\nassets\nindividually, we would  have\nn\nAPI calls. Here we pass list of\nassets\nâ€” this makes 1 API call to update all\nn\nassets\nat the same time.\nThe response will include all\nn\nassets\nthat were updated.\nAdd certificate to multiple existing assets\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\nval\nassets\n=\nmutableListOf\n<\nAsset\n>\n();\nassets\n.\nadd\n(\nGlossaryTerm\n// (1)\n.\nupdater\n(\n\"gsNccqJraDZqM6WyGP3ea@FzCMyPR2LxkPFgr8eNGrq\"\n,\n// (2)\n\"Example Term\"\n,\n\"b4113341-251b-4adc-81fb-2420501c30e6\"\n)\n.\ncertificateStatus\n(\nCertificateStatus\n.\nDEPRECATED\n)\n// (3)\n.\ncertificateStatusMessage\n(\n\"This asset should no longer be used.\"\n)\n.\nbuild\n())\n// (4)\nassets\n.\nadd\n(\nGlossaryTerm\n.\nupdater\n(\n\"sduw38sCas83Ca8sdf982@FzCMyPR2LxkPFgr8eNGrq\"\n,\n// (5)\n\"Another Term\"\n,\n\"b267858d-8316-4c41-a56a-6e9b840cef4a\"\n)\n.\ncertificateStatus\n(\nCertificateStatus\n.\nDEPRECATED\n)\n.\ncertificateStatusMessage\n(\n\"This asset should no longer be used.\"\n)\n.\nbuild\n())\n// (6)\nval\nresponse\n=\nclient\n// (7)\n.\nassets\n.\nsave\n(\nassets\n,\nfalse\n)\n// (8)\nassert\n(\nresponse\n.\nupdatedAssets\n.\nsize\n==\n2\n)\n// (9)\nDefine our object directly into an element of a\nList\n, rather than managing a separate object.\nUse the\nupdater()\nmethod to initialize the object with all\nnecessary attributes for updating it\n.\nDirectly chain our enrichment methods to add the certificate and message onto the\nupdater()\nmethod's result.\nCall the\nbuild()\nmethod to build the enriched object.\nUse the\nupdater()\nmethod to initialize the object for another\nasset\n.\nChain the enrichment and\nbuild()\nmethods like we did for the previous\nasset\n.\nTo optimize our update, we want to limit the number of API calls we make. If we called\nsave()\nagainst each of\nn\nassets\nindividually, we would have\nn\nAPI calls. To avoid this we use an\nAtlanClient\nthrough which to connect to the tenant.\nHere we use the client directly with a list of\nassets\nâ€” this makes 1 API call to update all\nn\nassets\nat the same time.\nThe response will include all\nn\nassets\nthat were updated.\nPOST /api/meta/entity/bulk\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n{\n\"entities\"\n:\n[\n// (1)\n{\n\"typeName\"\n:\n\"AtlasGlossaryTerm\"\n,\n// (2)\n\"attributes\"\n:\n{\n\"name\"\n:\n\"Example Term\"\n,\n// (3)\n\"qualifiedName\"\n:\n\"gsNccqJraDZqM6WyGP3ea@FzCMyPR2LxkPFgr8eNGrq\"\n,\n\"anchor\"\n:\n{\n\"typeName\"\n:\n\"AtlasGlossary\"\n,\n\"guid\"\n:\n\"b4113341-251b-4adc-81fb-2420501c30e6\"\n},\n\"certificateStatus\"\n:\n\"DEPRECATED\"\n,\n// (4)\n\"certificateStatusMessage\"\n:\n\"This asset should no longer be used.\"\n}\n},\n{\n// (5)\n\"typeName\"\n:\n\"AtlasGlossaryTerm\"\n,\n\"attributes\"\n:\n{\n\"name\"\n:\n\"Another Term\"\n,\n\"qualifiedName\"\n:\n\"sduw38sCas83Ca8sdf982@FzCMyPR2LxkPFgr8eNGrq\"\n,\n\"anchor\"\n:\n{\n\"typeName\"\n:\n\"AtlasGlossary\"\n,\n\"guid\"\n:\n\"b267858d-8316-4c41-a56a-6e9b840cef4a\"\n},\n\"certificateStatus\"\n:\n\"DEPRECATED\"\n,\n\"certificateStatusMessage\"\n:\n\"This asset should no longer be used.\"\n}\n}\n]\n}\nAll details must still be included in an outer\nentities\narray.\nYou need to specify the type for each asset you are updating.\nYou need to specify other required attributes for each asset, such as its name and qualifiedName. (And in the case of terms and categories, also the parent glossary they exist within.)\nAdd on any other attributes or relationships you want to set on the asset, such as in this example for a deprecation certificate.\nAdd another object to the payload to represent another asset that should be updated by the same API call. Once again specify all the required information for that kind of asset, and any of the details for attributes or relationships you want to set.\nAnd you can naturally combine this with\nmultiple operations\nper asset â€” to make many changes to many assets, all in a single API call.\nBe aware of how much you're updating per request\nWhile this is great for reducing the number of API calls for better performance, do be aware of how many objects you're trying to update per request. There will be a limit beyond which you are trying to send too much information through a single API call and you could see other impacts such as failed requests due to network timeouts.\nAs a starting point, we would suggest using a maximum of 20 assets per batch.\n2023-04-12\n2024-12-11\nWas this page helpful?\nThanks for your feedback!\nThanks for your feedback! Help us improve this page by using our\nfeedback form\nto provide us with more information.\nBack to top\nCookie consent\nWe use cookies to:\nAnonymously measure page views, and\nAllow you to give us one-click feedback on any page.\nWe do\nnot\ncollect or store:\nAny personally identifiable information.\nAny information for any (re)marketing purposes.\nWith your consent, you're helping us to make our documentation better ðŸ’™\nGoogle Analytics\nAccept\nReject\nManage settings",
  "source_type": "sdk"
}