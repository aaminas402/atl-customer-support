{
  "source_url": "snippets_common-examples_finding.html",
  "text": "Finding assets - overview - Developer\nSkip to content\nGet all assets that...\nÂ¶\nOne of the most common starting points for an algorithm is to retrieve all assets that meet certain criteria.\nTo contrast approaches, let's start with an example:\nImagine you might want to do something with all the columns in a particular schema (irrespective of the table or view they are in).\nAs a traversal\nÂ¶\nYou might logically consider the problem as a traversal:\nTraversal algorithm (pseudocode)\n1. Retrieve the schema.\n2. Retrieve all the tables in that schema.\na. For each table, retrieve all the columns.\nWhat you'll get from the table is actually just a reference â€” the GUID and\nqualifiedName\nof the column, but no details.\ni. For each column reference, retrieve its details.\nNow do something with the column.\n3. Retrieve all the views in that schema.\na. For each view, retrieve all the columns.\nWhat you'll get from the table is actually just a reference â€” the GUID and\nqualifiedName\nof the column, but no details.\ni. For each column reference, retrieve its details.\nNow do something with the column.\nWhile logical, this will be resource-intensive and time-consuming\nSuch an algorithm is certainly logical. However, you need to consider what's really happening behind-the-scenes. As the layout of the pseudocode above hopefully illustrates, there are a number of nested loops:\n(2) and (3) are loops, and within those loops you are making an API call per asset (table or view) to retrieve other assets. At first glance, this creates an algorithm whose runtime will grow roughly\nlinearly with the number of tables and views in the schema\n.\nHowever, when retrieving the columns through the relationships on a table or view, you only get a\nreference\nto the column, not the full details of the column. So in reality, you then need to retrieve each column. The linear time complexity is now approaching\nquadratic\n. This will become\nmuch\nslower as volumes grow.\nAs a search\nÂ¶\nIn almost all cases, you can more quickly accomplish your goal by using search. For the example above:\nSearch-based algorithm (pseudocode)\n1. Run a search.\nUsing the following conditions:\nLimit assets by\ntype\n, to only columns.\nLimit results by\nstatus\n, to only active (non-archived) assets.\nSearch by\nprefix\nusing the\nqualifiedName\nof the schema.\nRequest only the attributes you need to be included in each column result.\n2. Iterate through the results.\nNow do something with the column.\nLess code (fewer loops), and faster to run\nWith this algorithm, you'll only make as many API calls as there are pages of results. (So if you have a page size of 100 and there are 10,000 columns, that's 100 API calls â€” compared to the other algorithm's 10,000+ API calls with one per column.)\nIn general when you want to get many assets, think search first\nThis was only one example to show the approach. The sections below illustrate a number of them, but you may have many, many others.\nEach of these can be accomplished through a search â€” you just need to define the appropriate criteria! To do that, you might want to read up a bit more on\nsearch in general\n. It's incredibly powerful, but we know it is not trivial to understand when you're first getting started.\nTop tip\n: you can\ncombine\nthese examples together to form an even more powerful query, using\ncompound queries\n.\n2022-10-12\n2024-03-14\nWas this page helpful?\nThanks for your feedback!\nThanks for your feedback! Help us improve this page by using our\nfeedback form\nto provide us with more information.\nBack to top\nCookie consent\nWe use cookies to:\nAnonymously measure page views, and\nAllow you to give us one-click feedback on any page.\nWe do\nnot\ncollect or store:\nAny personally identifiable information.\nAny information for any (re)marketing purposes.\nWith your consent, you're helping us to make our documentation better ðŸ’™\nGoogle Analytics\nAccept\nReject\nManage settings",
  "source_type": "sdk"
}