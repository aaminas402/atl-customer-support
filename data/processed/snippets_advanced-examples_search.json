{
  "source_url": "snippets_advanced-examples_search.html",
  "text": "Searching for assets - Developer\nSkip to content\nSearching for assets\nÂ¶\nSearching is a very flexible operation in Atlan. This also makes it a bit more complex to understand than the other operations. To encapsulate the full flexibility of Atlan's search, the SDK provides a dedicated\nIndexSearchRequest\nobject and a\nFluentSearch\nclass for configuring such a request using a fluent builder pattern.\nMore details on the power and flexibility of searching\nSee the dedicated\nSearching\nsection of this site for more details on Atlan's search. This covers the various kinds of searches you can run, and the detailed attributes you can search against.\nBuild the query\nÂ¶\n0.1.0\n1.0.0\n2.0.0\nTo run a search in Atlan, you need to define the query using Elastic's structures. While you can always use Elastic's own structures to make use of its full power, for the vast majority of cases you may find it easier to use the helpers built-in to the SDK:\nJava\nPython\nKotlin\nGo\nRaw REST API\nBuild the query\n1\n2\n3\nFluentSearch\n.\nFluentSearchBuilder\n<?\n,\n?>\nbuilder\n=\nclient\n.\nassets\n.\nselect\n()\n// (1)\n.\nactive\n()\n// (2)\n.\nwhere\n(\nAsset\n.\nTYPE_NAME\n.\neq\n(\nGlossaryTerm\n.\nTYPE_NAME\n));\n// (3)\nYou can start building a query across all assets using the\nselect()\nmethod on the\nassets\nmember of any client. You can chain as many conditions as you want:\nwhere()\nis mandatory inclusion\nwhereNot()\nis mandatory exclusion\nwhereSome()\nfor conditions where some of them must match\nThis helper provides a query that ensures results are active (not archived) assets.\nEquivalent Elastic query\nQuery\nbeActive\n=\nTermQuery\n.\nof\n(\nm\n->\nm\n.\nfield\n(\n\"__state\"\n)\n.\nvalue\n(\nAtlanStatus\n.\nACTIVE\n.\ngetValue\n()))\n.\n_toQuery\n();\nThis condition provides a query that restricts results to a specific type of assets (glossary terms in this example).\nEquivalent Elastic query\nQuery\nbeTerm\n=\nTermQuery\n.\nof\n(\nm\n->\nm\n.\nfield\n(\n\"__typeName.keyword\"\n)\n.\nvalue\n(\nGlossaryTerm\n.\nTYPE_NAME\n))\n.\n_toQuery\n();\nBuild the query\n1\n2\n3\n4\n5\n6\n7\n8\n9\nfrom\npyatlan.client.atlan\nimport\nAtlanClient\nfrom\npyatlan.model.assets\nimport\nAsset\n,\nAtlasGlossaryTerm\nfrom\npyatlan.model.fluent_search\nimport\nCompoundQuery\n,\nFluentSearch\nbuilder\n=\n(\nFluentSearch\n()\n# (1)\n.\nwhere\n(\nCompoundQuery\n.\nactive_assets\n())\n# (2)\n.\nwhere\n(\nCompoundQuery\n.\nasset_type\n(\nAtlasGlossaryTerm\n))\n# (3)\n)\nYou can start building a query using a\nFluentSearch\nobject. You can have as many mandatory (\nwhere()\n) conditions, mandatory exclusion (\nwhere_not()\n) conditions, and set of conditions some of which must match (\nwhere_some()\n) as you want.\nThis helper provides a query that ensures results are active (not archived) assets.\nThis helper provides a query that restricts results to a specific type of assets (glossary terms in this example).\nBuild the query\n1\n2\n3\nval\nbuilder\n=\nclient\n.\nassets\n.\nselect\n()\n// (1)\n.\nactive\n()\n// (2)\n.\nwhere\n(\nAsset\n.\nTYPE_NAME\n.\neq\n(\nGlossaryTerm\n.\nTYPE_NAME\n))\n// (3)\nYou can start building a query across all assets using the\nselect()\nmethod on the\nassets\nmember of any client. You can chain as many mandatory (\nwhere()\n) conditions, mandatory exclusion (\nwhereNot()\n) conditions, and set of conditions some of which must match (\nwhereSome()\n) as you want.\nThis helper provides a query that ensures results are active (not archived) assets.\nEquivalent Elastic query\nval\nbeActive\n=\nTermQuery\n.\nof\n(\nm\n->\nm\n.\nfield\n(\n\"__state\"\n)\n.\nvalue\n(\nAtlanStatus\n.\nACTIVE\n.\ngetValue\n()))\n.\n_toQuery\n()\nThis helper provides a query that restricts results to a specific type of assets (glossary terms in this example).\nEquivalent Elastic query\nval\nbeTerm\n=\nTermQuery\n.\nof\n(\nm\n->\nm\n.\nfield\n(\n\"__typeName.keyword\"\n)\n.\nvalue\n(\nGlossaryTerm\n.\nTYPE_NAME\n))\n.\n_toQuery\n()\nBuild the query\n1\n2\n3\nbuilder\n:=\nassets\n.\nNewFluentSearch\n().\n// (1)\nActiveAssets\n().\n// (2)\nAssetType\n(\n\"AtlasGlossaryTerm\"\n).\n// (3)\nYou can start building a query using a\nFluentSearch\nobject. You can have as many mandatory (\nwhere()\n) conditions, mandatory exclusion (\nWhereNot()\n) conditions, and set of conditions some of which must match (\nWhereSome()\n) as you want.\nThis helper provides a query that ensures results are active (not archived) assets.\nThis helper provides a query that restricts results to a specific type of assets (glossary terms in this example).\nQuery contents\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\"bool\"\n:\n{\n// (1)\n\"filter\"\n:\n[\n// (2)\n{\n\"term\"\n:\n{\n// (3)\n\"__state\"\n:\n{\n// (4)\n\"value\"\n:\n\"ACTIVE\"\n// (5)\n}\n}\n},\n{\n\"term\"\n:\n{\n\"__typeName.keyword\"\n:\n{\n// (6)\n\"value\"\n:\n\"AtlasGlossaryTerm\"\n// (7)\n}\n}\n}\n]\n}\nA\nbool\nquery combines together multiple conditions.\nA\nfilter\nclause exactly matches all of the conditions, without scoring (so can be slightly faster than other scoring-based combination mechanisms).\nTerm queries are generally used to exactly match values.\nThe\n__state\nfield will match the status of an asset in Atlan.\nSo in this example you will only match assets that are currently ACTIVE (not archived or soft-deleted).\nYou will also only match assets that are of a specific type, since\n__typeName.keyword\nwill match the type of asset.\nNote these names do not exactly match attribute names\nNote that these names are field names in the search index, and may vary from the attribute names of the assets in Atlan. To find the appropriate field name and how it relates to an attribute name, use the\nfull model reference\n.\nIn this example, you will only match terms.\nBuild the request\nÂ¶\n0.0.17\n1.0.0\n1.1.0\nOnce the query is defined, we can then build up the search request. The request includes not only the query, but also parameters like paging and which attributes to include in the response:\nJava\nPython\nKotlin\nGo\nRaw REST API\nBuild the request\n4\n5\n6\n7\n8\nIndexSearchRequest\nindex\n=\nbuilder\n// (1)\n.\npageSize\n(\n100\n)\n// (2)\n.\nincludeOnResults\n(\nGlossaryTerm\n.\nANCHOR\n)\n// (3)\n.\nincludeOnRelations\n(\nAsset\n.\nCERTIFICATE_STATUS\n)\n// (4)\n.\ntoRequest\n();\n// (5)\nYou can then chain additional parameters onto the fluent search. (You could of course do this all directly as part of the same chain, you do not need to store the interim\nbuilder\nvariable.)\nThe number of results to include (per page).\nYou can chain as many attributes as you want to include in each result. In this case we will return the\nanchor\nattribute for terms, which gives the relationship from the term to its parent glossary.\nYou can chain as many attributes to include on each related asset to each result. Since we are returning\nanchor\nrelationships, this will ensure that the\ncertificateStatus\nof those related glossaries is also included in each result.\nYou can now build all of this search configuration into a request.\nBuild the request\n10\n11\n12\n13\n14\n15\nindex\n=\n(\nbuilder\n# (1)\n.\npage_size\n(\n100\n)\n# (2)\n.\ninclude_on_results\n(\nAtlasGlossaryTerm\n.\nANCHOR\n)\n# (3)\n.\ninclude_on_relations\n(\nAsset\n.\nCERTIFICATE_STATUS\n)\n# (4)\n)\n.\nto_request\n()\n# (5)\nYou can then chain additional parameters onto the fluent search. (You could of course do this all directly as part of the same chain, you do not need to store the interim\nbuilder\nvariable.)\nThe number of results to include (per page).\nYou can chain as many attributes as you want to include in each result. In this case we will return the\nanchor\nattribute for terms, which gives the relationship from the term to its parent glossary.\nYou can chain as many attributes to include on each related asset to each result. Since we are returning\nanchor\nrelationships, this will ensure that the\ncertificate_status\nof those related glossaries is also included in each result.\nYou can now build all of this search configuration into a request.\nBuild the request\n4\n5\n6\n7\n8\nval\nindex\n=\nbuilder\n// (1)\n.\npageSize\n(\n100\n)\n// (2)\n.\nincludeOnResults\n(\nGlossaryTerm\n.\nANCHOR\n)\n// (3)\n.\nincludeOnRelations\n(\nAsset\n.\nCERTIFICATE_STATUS\n)\n// (4)\n.\ntoRequest\n()\n// (5)\nYou can then chain additional parameters onto the fluent search. (You could of course do this all directly as part of the same chain, you do not need to store the interim\nbuilder\nvariable.)\nThe number of results to include (per page).\nYou can chain as many attributes as you want to include in each result. In this case we will return the\nanchor\nattribute for terms, which gives the relationship from the term to its parent glossary.\nYou can chain as many attributes to include on each related asset to each result. Since we are returning\nanchor\nrelationships, this will ensure that the\ncertificateStatus\nof those related glossaries is also included in each result.\nYou can now build all of this search configuration into a request.\nBuild the request\n4\n5\n6\n7\n8\nindex\n:=\nbuilder\n.\n// (1)\nPageSize\n(\n100\n).\n// (2)\nIncludeOnResults\n(\n\"anchor\"\n).\n// (3)\nIncludeOnRelations\n(\n\"certificateStatus\"\n).\n// (4)\nToRequest\n()\n// (5)\nYou can then chain additional parameters onto the fluent search. (You could of course do this all directly as part of the same chain, you do not need to store the interim\nbuilder\nvariable.)\nThe number of results to include (per page).\nYou can chain as many attributes as you want to include in each result. In this case we will return the\nanchor\nattribute for terms, which gives the relationship from the term to its parent glossary.\nYou can chain as many attributes to include on each related asset to each result. Since we are returning\nanchor\nrelationships, this will ensure that the\ncertificateStatus\nof those related glossaries is also included in each result.\nYou can now build all of this search configuration into a request for executing.\nPOST /api/meta/search/indexsearch\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n{\n\"dsl\"\n:\n{\n// (1)\n\"from\"\n:\n0\n,\n// (2)\n\"size\"\n:\n100\n,\n\"query\"\n:\n{\n// (3)\n},\n\"track_total_hits\"\n:\ntrue\n// (4)\n},\n\"attributes\"\n:\n[\n// (5)\n\"anchor\"\n],\n\"relationAttributes\"\n:\n[\n// (6)\n\"certificateStatus\"\n],\n\"suppressLogs\"\n:\ntrue\n,\n\"showSearchScore\"\n:\nfalse\n,\n\"excludeMeanings\"\n:\nfalse\n,\n// (7)\n\"excludeClassifications\"\n:\nfalse\n}\nA query should always be defined within the\ndsl\nportion of the request.\nIn addition to the query, you can specify\nfrom\nand\nsize\nparameters for pagination.\nThe query itself should be provided within the\nquery\nportion of the\ndsl\n. Here you would use the query body provided in the earlier step.\nYou must set\ntrack_total_hits\nto\ntrue\nif you want an exact count of the number of results (in particular for pagination).\nThe list of attributes to include in each result. In this case we will return the\nanchor\nattribute for terms, which gives the relationship from the term to its parent glossary.\nThe list of attributes to include on each relationship that is included in each result. Since we are returning\nanchor\nrelationships, this will ensure that the\ncertificateStatus\nof those related glossaries is also included in each result.\nYou can also choose whether to include other related information, such as the terms and Atlan tags assigned to each result. In general, only include the information you require â€” this will provide the best performance.\n(Optional) Build request directly from JSON\nÂ¶\n5.0.0\nWhile we recommend\nusing\nFluentSearch\nto build search requests, there might be scenarios where quick prototyping or testing of search queries is needed. For such use cases, we also support directly constructing search requests from raw JSON.\nJava\nPython\nKotlin\nRaw REST API\nComing soon\nBuild request directly from JSON\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\nfrom\npyatlan.model.search\nimport\nIndexSearchRequest\nraw_json_payload\n=\nr\n\"\"\"\n{\n\"dsl\": {\n\"from_\": 0,\n\"size\": 100,\n\"aggregations\":\n{}\n,\n\"track_total_hits\": true,\n\"query\": {\n\"bool\": {\n\"filter\": [\n{\n\"term\": {\n\"__state\": {\n\"value\": \"ACTIVE\",\n\"case_insensitive\": false\n}\n}\n},\n{\n\"term\": {\n\"__typeName.keyword\": {\n\"value\": \"AtlasGlossaryTerm\",\n\"case_insensitive\": false\n}\n}\n}\n]\n}\n},\n\"sort\": [\n{\n\"__guid\": {\n\"order\": \"asc\"\n}\n}\n]\n},\n\"attributes\": [\n\"anchor\"\n],\n\"relation_attributes\": [\n\"certificateStatus\"\n],\n\"suppress_logs\": true,\n\"show_search_score\": false,\n\"exclude_meanings\": false\n}\n\"\"\"\nindex\n=\nIndexSearchRequest\n.\nparse_raw\n(\nraw_json_payload\n)\n# (1)\nYou can use Pydantic's\n.parse_raw(raw_json_payload)\nmethod to parse a JSON string and construct an SDK\nIndexSearchRequest\nobject. If you're using a dictionary instead of a JSON string, use\n.parse_obj(dict_payload)\ninstead.\nComing soon\nPOST /api/meta/search/indexsearch\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n{\n\"dsl\"\n:\n{\n// (1)\n\"from\"\n:\n0\n,\n// (2)\n\"size\"\n:\n100\n,\n\"query\"\n:\n{\n// (3)\n},\n\"track_total_hits\"\n:\ntrue\n// (4)\n},\n\"attributes\"\n:\n[\n// (5)\n\"anchor\"\n],\n\"relationAttributes\"\n:\n[\n// (6)\n\"certificateStatus\"\n],\n\"suppressLogs\"\n:\ntrue\n,\n\"showSearchScore\"\n:\nfalse\n,\n\"excludeMeanings\"\n:\nfalse\n,\n// (7)\n\"excludeClassifications\"\n:\nfalse\n}\nA query should always be defined within the\ndsl\nportion of the request.\nIn addition to the query, you can specify\nfrom\nand\nsize\nparameters for pagination.\nThe query itself should be provided within the\nquery\nportion of the\ndsl\n. Here you would use the query body provided in the earlier step.\nYou must set\ntrack_total_hits\nto\ntrue\nif you want an exact count of the number of results (in particular for pagination).\nThe list of attributes to include in each result. In this case we will return the\nanchor\nattribute for terms, which gives the relationship from the term to its parent glossary.\nThe list of attributes to include on each relationship that is included in each result. Since we are returning\nanchor\nrelationships, this will ensure that the\ncertificateStatus\nof those related glossaries is also included in each result.\nYou can also choose whether to include other related information, such as the terms and Atlan tags assigned to each result. In general, only include the information you require â€” this will provide the best performance.\nRun the search\nÂ¶\n0.1.0\n1.4.0\n4.0.0\nTo now run the search, we call the\nsearch()\nmethod against our request object:\nJava\nPython\nKotlin\nGo\nRaw REST API\nRun the search\n9\n10\nIndexSearchResponse\nresponse\n=\nindex\n.\nsearch\n(\nclient\n);\nlog\n.\ninfo\n(\nresponse\n.\ngetApproximateCount\n())\n// (1)\nThe\ngetApproximateCount()\nmethod gives the total number of results overall (not restricted by page).\nRun the search\n16\n17\nresults\n=\nclient\n.\nasset\n.\nsearch\n(\nindex\n)\nprint\n(\nresults\n.\ncount\n)\n# (1)\nThe\ncount\nproperty gives the total number of results overall (not restricted by page).\nRun the search\n9\n10\nval\nresponse\n=\nindex\n.\nsearch\n(\nclient\n)\nlog\n.\ninfo\n(\nresponse\n.\napproximateCount\n);\n// (1)\nThe\n.approximateCount\nmember gives the total number of results overall (not restricted by page).\nRun the search\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\nresults\n,\n_\n:=\nassets\n.\nSearch\n(\n*\nindex\n)\n// (1)\nfmt\n.\nPrintf\n(\n\"Found %d assets\\n\"\n,\nresults\n.\nCount\n())\n// (2)\nentities\n,\nerrIter\n:=\nresults\n.\nIter\n()\n// (3)\nfor\nasset\n:=\nrange\nentities\n{\n// (4)\nfmt\n.\nPrintln\n(\n\"asset name:\"\n,\n*\nasset\n.\nName\n)\n}\nif\nerr\n:=\n<-\nerrIter\n;\nerr\n!=\nnil\n{\n// (5)\nfmt\n.\nPrintln\n(\n\"Error during iteration:\"\n,\nerr\n)\n}\nThis will execute the search and return the first page of results.\nThe\nApproximateCount\nproperty gives the total number of results overall (not restricted by page).\nWhen working with paginated search results, the\n.Iter()\nmethod\nprovides a convenient way to iterate over all results without manually handling pagination.\nYou can then directly iterate through the search results.\nThe SDK handles pagination for you, fetching each page lazily as needed.\nIf an error occurs during iteration (e.g: a failed API request),\nit is sent to the\nerrIter\nchannel. The iteration stops, and you can handle the error accordingly.\nImplicit in the previous step\nActually running the search is implicit in the example above for the previous raw API step.\nIterate through results\nÂ¶\nOne page of results\nÂ¶\n0.1.0\n1.0.0\n1.1.0\nTo iterate through one page of results, loop through the list of assets:\nJava\nPython\nKotlin\nGo\nRaw REST API\nIterate through one page of results\n11\n12\n13\n14\n15\n16\nList\n<\nAsset\n>\nresults\n=\nresponse\n.\ngetAssets\n();\n// (1)\nfor\n(\nAsset\nresult\n:\nresults\n)\n{\n// (2)\nif\n(\nresult\ninstanceof\nGlossaryTerm\n)\n{\nGlossaryTerm\nterm\n=\n(\nGlossaryTerm\n)\nresult\n;\n// (3)\n}\n}\nThe page of results itself can be accessed through the\ngetAssets()\nmethod on the response.\nYou can then iterate through these results from a single page.\nRemember that each result is a generic\nAsset\n. In our example we searched for a specific type, but another example may search for any asset with a given name (or Atlan tag) â€” so each result could be a different type. So again we should check and cast the results as-needed.\nIterate through one page of results\n18\n19\n20\nfor\nasset\nin\nresults\n.\ncurrent_page\n():\n# (1)\nif\nisinstance\n(\nasset\n,\nAtlasGlossaryTerm\n):\n# (2)\nterm\n=\nasset\nYou can iterate through the results from a single page.\nRemember per the type hints each result is a generic\nAsset\n. In our example we searched for a specific type, but another example may search for any asset with a given name (or Atlan tags) - so each result could be a different type. So if we want to take allow an IDE to provide better code completion, we need include an\nif isinstance(asset, asset_type)\nwhere\nasset_type\nis the type of the asset we want the IDE to know about. Inside the IDE will know the object is of the specified type. It's also a good practice that will prevent run-time errors if an asset is not of the expected type.\nIterate through one page of results\n11\n12\n13\n14\n15\n16\nval\nresults\n=\nresponse\n.\nassets\n// (1)\nfor\n(\nresult\nin\nresults\n)\n{\n// (2)\nif\n(\nresult\nis\nGlossaryTerm\n)\n{\nval\nterm\n=\nresult\n// (3)\n}\n}\nThe page of results itself can be accessed through the\n.assets\nmember on the response.\nYou can then iterate through these results from a single page.\nRemember that each result is a generic\nAsset\n. In our example we searched for a specific type, but another example may search for any asset with a given name (or Atlan tag) â€” so each result could be a different type. So again we should check and cast the results as-needed.\nIterate through one page of results\n14\n15\n16\n17\n18\n19\n20\ncurrent\n,\n_\n:=\nresults\n.\nCurrentPage\n()\n// (1)\nfor\n_\n,\nasset\n:=\nrange\ncurrent\n.\nEntities\n{\nif\n*\nasset\n.\nTypeName\n==\n\"AtlasGlossaryTerm\"\n{\n// (2)\n// Do something with AtlasGlossaryTerm\n}\n}\nYou can iterate through the results from a single page.\nYou can filter the asset based on the typename and perform operations on the asset.\nEach object in\nentities\nis a matching asset\nEach item in the\nentities\narray of the response will give details about a matching asset.\nMultiple pages of results\nÂ¶\n0.0.17\n1.0.0\n1.1.0\nTo iterate through multiple pages of results:\nJava\nPython\nKotlin\nGo\nRaw REST API\nIterate through multiple pages of results\n11\n12\n13\nfor\n(\nAsset\nresult\n:\nresponse\n)\n{\n// (1)\n// Do something with each result in the page of results...\n}\nYou can simply iterate over the reponse itself. This will lazily load and loop through each page of results until the loop finishes or you break out of it. (You could also use\nresponse.forEach()\n, which uses the same iteratable-based implementation behind-the-scenes.)\nIterate through multiple pages of results (streaming)\n11\n12\n13\n14\nresponse\n.\nstream\n()\n// (1)\n.\nlimit\n(\n100\n)\n// (2)\n.\nfilter\n(\na\n->\n!\n(\na\ninstanceof\nILineageProcess\n))\n// (3)\n.\nforEach\n(\na\n->\nlog\n.\ninfo\n(\n\"Do something with each result: {}\"\n,\na\n));\n// (4)\nAlternatively, you can also stream the results direct from the response. This will also lazily load and loop through each page of results.\nCan be chained without creating a request in-between\nYou can actually chain the\nstream()\nmethod directly onto the end of your query and request construction, without creating a\nrequest\nor\nresponse\nobject in-between.\nWith streaming, you can apply your own limits to the maximum number of results you want to process.\nIndependent of page size\nNote that this is independent of page size. You could page through results 50 at a time, but only process a maximum of 100 total results this way. Since the results are lazily-loaded when streaming, only the first two pages of results would be retrieved in such a scenario.\nYou can also apply your own logical filters to the results.\nPush-down as much as you can to the query\nYou should of course push-down as many of the filters as you can to the query itself, but if you have a particular complex check to apply that cannot be encoded in the query this can be a useful secondary filter over the results.\nThe\nforEach()\non the resulting stream will then apply whatever actions you want with the results that come through.\nIterate through multiple pages of results one page at a time\n18\n19\n20\n21\n22\n23\nwhile\nresults\n.\ncurrent_page\n():\n# (1)\nfor\nasset\nin\nresults\n.\ncurrent_page\n():\n# (2)\nif\nisinstance\n(\nasset\n,\nAtlasGlossaryTerm\n):\n# (3)\nterm\n=\nasset\nif\nnot\nresults\n.\nnext_page\n():\n# (4)\nbreak\n# (5)\nThe\ncurrent_page()\nmethod returns a\nlist\nof the assets for the current page. If there are none then an empty\nlist\nwill be returned.\nIterate through the assets in the current page.\nRemember per the type hints each result is a generic\nAsset\n. In our example we searched for a specific type, but another example may search for any asset with a given name (or classifications) - so each result could be a different type. So if we want to take allow an IDE to provide better code completion, we need include an\nif isinstance(asset, asset_type)\nwhere\nasset_type\nis the type of the asset we want the IDE to know about. Inside the IDE will know the object is of the specified type. It's also a good practice that will prevent run-time errors if an asset is not of the expected type.\nThe\nnext_pages()\nmethod retrieves the next page of results and return\nTrue\nif more assets are available and\nFalse\nif they are not.\nBreak out of the\nWhile\nloop if no more assets are available.\nAlternatively iterate through all the pages of results\n18\n19\n20\nfor\nasset\nin\nresults\n:\n# (1)\nif\nisinstance\n(\nasset\n,\nAtlasGlossaryTerm\n):\n# (2)\nterm\n=\nasset\nThis will iterate through all the results without the need to be concerned with pages.\nIterating over results produces a\nGenerator\nThis means that results are retrieved from the backend a page at time. This also means that you can only iterate over the results once.\nRemember that each result is a generic\nAsset\n. In our example we searched for a specific type, but another example may search for any asset with a given name (or classification) â€” so each result could be a different type. So again we should check and cast the results as-needed.\nIterate through multiple pages of results\n11\n12\n13\nfor\n(\nresult\nin\nresponse\n)\n{\n// (1)\n// Do something with each result in the page of results...\n}\nYou can simply iterate over the reponse itself. This will lazily load and loop through each page of results until the loop finishes or you break out of it. (You could also use\nresponse.forEach{ }\n, which uses the same iteratable-based implementation behind-the-scenes.)\nIterate through multiple pages of results (streaming)\n11\n12\n13\n14\nresponse\n.\nstream\n()\n// (1)\n.\nlimit\n(\n100\n)\n// (2)\n.\nfilter\n{\nit\n!is\nILineageProcess\n}\n// (3)\n.\nforEach\n{\nlog\n.\ninfo\n(\n\"Do something with each result: {}\"\n,\nit\n)\n}\n// (4)\nAlternatively, you can also stream the results direct from the response. This will also lazily load and loop through each page of results.\nCan be chained without creating a request in-between\nYou can actually chain the\nstream()\nmethod directly onto the end of your query and request construction, without creating a\nrequest\nor\nresponse\nobject in-between.\nWith streaming, you can apply your own limits to the maximum number of results you want to process.\nIndependent of page size\nNote that this is independent of page size. You could page through results 50 at a time, but only process a maximum of 100 total results this way. Since the results are lazily-loaded when streaming, only the first two pages of results would be retrieved in such a scenario.\nYou can also apply your own logical filters to the results.\nPush-down as much as you can to the query\nYou should of course push-down as many of the filters as you can to the query itself, but if you have a particular complex check to apply that cannot be encoded in the query this can be a useful secondary filter over the results.\nThe\nforEach{ }\non the resulting stream will then apply whatever actions you want with the results that come through.\nIterate through multiple pages of results one page at a time\n14\n15\n16\n17\n18\n19\n20\n21\n22\nentities\n,\nerrIter\n:=\nresults\n.\nIter\n()\n// (1)\nfor\nasset\n:=\nrange\nentities\n{\n// (2)\nfmt\n.\nPrintln\n(\n\"asset name:\"\n,\n*\nasset\n.\nName\n)\n}\nif\nerr\n:=\n<-\nerrIter\n;\nerr\n!=\nnil\n{\n// (3)\nfmt\n.\nPrintln\n(\n\"Error during iteration:\"\n,\nerr\n)\n}\nWhen working with paginated search results, the\n.Iter()\nmethod\nprovides a convenient way to iterate over all results without manually handling pagination.\nYou can then directly iterate through the search results.\nThe SDK handles pagination for you, fetching each page lazily as needed.\nIf an error occurs during iteration (e.g: a failed API request),\nit is sent to the\nerrIter\nchannel. The iteration stops, and you can handle the error accordingly.\nUse the\nsearchParameters.query\nof the response\nEach search response includes a\nsearchParameters\nwith a nested\nquery\nstring. This query string gives the details of the query that was run to produce the response â€” so to get a next page you can:\nUse this\nquery\nstring from the response to start building a new query using the same logic.\nAdd the page size to the\nfrom\nparameter embedded in that query string, to give the starting point for the next page of results.\nRe-include any\nattributes\nor\nrelationAttributes\nfrom the query string into the new query.\nSend this new query to retrieve the next page of results.\n2022-09-14\n2025-03-26\nWas this page helpful?\nThanks for your feedback!\nThanks for your feedback! Help us improve this page by using our\nfeedback form\nto provide us with more information.\nBack to top\nCookie consent\nWe use cookies to:\nAnonymously measure page views, and\nAllow you to give us one-click feedback on any page.\nWe do\nnot\ncollect or store:\nAny personally identifiable information.\nAny information for any (re)marketing purposes.\nWith your consent, you're helping us to make our documentation better ðŸ’™\nGoogle Analytics\nAccept\nReject\nManage settings",
  "source_type": "sdk"
}