{
  "source_url": "snippets_advanced-examples_update.html",
  "text": "Updating an asset - Developer\nSkip to content\nUpdating an asset\n¶\nAll objects in the SDK that you can update within Atlan implement the builder pattern. This allows you to progressively build-up the object you want to update. In addition, each object provides a method that takes the minimal set of required fields to\nupdate\nthat\nasset\n, when it already exists in Atlan.\nInclude only your intended changes, nothing more\nWhen enriching an asset in Atlan, you only need to specify the information you want to change. Any information you do not include in your update will be left untouched on the asset in Atlan. This way you do not need to:\ntry to reproduce the complete asset in your request to do targeted updates to specific attributes\nworry about other changes that may be made to the asset in parallel to the changes you will be making to the asset\nBuild minimal object needed\n¶\n2.0.0\n1.0.0\nFor example, to update a glossary term we need to provide the\nqualifiedName\nand name of the term, and the GUID of the glossary in which it exists:\nJava\nPython\nKotlin\nRaw REST API\nBuild minimal asset necessary for update\n1\n2\n3\n4\nGlossaryTermBuilder\n<?\n,\n?>\ntermUpdater\n=\nGlossaryTerm\n.\nupdater\n(\n\"gsNccqJraDZqM6WyGP3ea@FzCMyPR2LxkPFgr8eNGrq\"\n,\n// (1)\n\"Example Term\"\n,\n// (2)\n\"b4113341-251b-4adc-81fb-2420501c30e6\"\n);\n// (3)\nThe\nqualifiedName\nof the existing term, which must match exactly (case-sensitive). Note that for some assets (like terms), this may be a strange-looking Atlan-internal string.\nThe name of the existing term. This must match exactly (case-sensitive).\nThe GUID of the glossary in which the term exists.\nBuild minimal asset necessary for update\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\nfrom\npyatlan.client.atlan\nimport\nAtlanClient\nfrom\npyatlan.model.assets\nimport\nAnnouncement\n,\nAtlasGlossaryTerm\nfrom\npyatlan.model.enums\nimport\nAnnouncementType\n,\nCertificateStatus\nclient\n=\nAtlanClient\n()\nterm\n=\nAtlasGlossaryTerm\n.\nupdater\n(\nqualified_name\n=\n\"gsNccqJraDZqM6WyGP3ea@FzCMyPR2LxkPFgr8eNGrq\"\n,\n# (1)\nname\n=\n\"Example Term\"\n,\n# (2)\nglossary_guid\n=\n\"b4113341-251b-4adc-81fb-2420501c30e6\"\n,\n# (3)\n)\nThe\nqualifiedName\nof the existing term, which must match exactly (case-sensitive). Note that for some assets (like terms), this may be a strange-looking Atlan-internal string.\nThe name of the existing term. This must match exactly (case-sensitive).\nThe GUID of the glossary in which the term exists.\nBuild minimal asset necessary for update\n1\n2\n3\n4\n5\n6\nval\ntermUpdater\n=\nGlossaryTerm\n.\nupdater\n(\n\"gsNccqJraDZqM6WyGP3ea@FzCMyPR2LxkPFgr8eNGrq\"\n,\n// (1)\n\"Example Term\"\n,\n// (2)\n\"b4113341-251b-4adc-81fb-2420501c30e6\"\n// (3)\n)\nThe\nqualifiedName\nof the existing term, which must match exactly (case-sensitive). Note that for some assets (like terms), this may be a strange-looking Atlan-internal string.\nThe name of the existing term. This must match exactly (case-sensitive).\nThe GUID of the glossary in which the term exists.\nImplicit in the API calls below\nThere is nothing specific to do for this step when using the raw APIs — constructing the object is simply what you place in the payload of the API calls in the steps below.\nWhat if I already have an asset (for example, from a search)?\nSince you should only include your intended changes, and nothing more, the SDKs provide a convenience method to reduce an asset down to its minimal properties.\nYou should use this method\nto trim an object in your code down to a starting point for the changes you want to make to that asset:\nJava\nPython\nTrim existing asset to minimal properties\n4\nGlossaryTermBuilder\n<?\n,\n?>\ntermUpdater\n=\nexisting\n.\ntrimToRequired\n();\n// (1)\nAssuming you have an existing asset in a variable called\nexisting\n, you can call\ntrimToRequired()\nto reduce it to a builder with the minimal properties needed to update that asset.\nTrim existing asset to minimal properties\n10\nterm\n=\nexisting\n.\ntrim_to_required\n()\n# (1)\nAssuming you have an existing asset in a variable called\nexisting\n, you can call\ntrim_to_required()\nto reduce it to an object with the minimal properties needed to update that asset.\nEnrich before updating\n¶\nThe\nterm\nobject now has the minimal required information for Atlan to update it. Without any additional enrichment, though, there isn't really anything to update...\n1.4.0\n1.0.0\nSo first you should enrich the object:\nJava\nPython\nKotlin\nRaw REST API\nEnrich the asset before updating it\n5\n6\n7\n8\n9\n10\nGlossaryTerm\nterm\n=\ntermUpdater\n// (1)\n.\ncertificateStatus\n(\nCertificateStatus\n.\nVERIFIED\n)\n// (2)\n.\nannouncementType\n(\nAtlanAnnouncementType\n.\nINFORMATION\n)\n// (3)\n.\nannouncementTitle\n(\n\"Imported\"\n)\n.\nannouncementMessage\n(\n\"This term was imported from ...\"\n)\n.\nbuild\n();\n// (4)\nWe'll create an object we can take actions on from this updater.\nIn this example, we're adding a certificate to the object.\nNote that you can chain any number of enrichments together. Here we are also adding an announcement to the asset.\nTo persist the enrichment back to the object, we must\nbuild()\nthe builder.\nAssign the result back\nRemember to assign the result of the\nbuild()\noperation back to your original object. Otherwise the result is not persisted back into any variable! (In this case we're assigning to the\nterm\nvariable back on line 5.)\nEnrich the asset before updating it\n11\n12\n13\n14\n15\n16\n17\nterm\n.\ncertificate_status\n=\nCertificateStatus\n.\nVERIFIED\n# (1)\nannouncement\n=\nAnnouncement\n(\nannouncement_type\n=\nAnnouncementType\n.\nINFORMATION\n,\nannouncement_title\n=\n\"Imported\"\n,\nannouncement_message\n=\n\"This term was imported from ..\"\n,\n)\nterm\n.\nset_announcement\n(\nannouncement\n)\n# (2)\nIn this example, we're adding a certificate to the object.\nIn this example, we're adding an announcement to the object.\nEnrich the asset before updating it\n7\n8\n9\n10\n11\n12\nval\nterm\n=\ntermUpdater\n// (1)\n.\ncertificateStatus\n(\nCertificateStatus\n.\nVERIFIED\n)\n// (2)\n.\nannouncementType\n(\nAtlanAnnouncementType\n.\nINFORMATION\n)\n// (3)\n.\nannouncementTitle\n(\n\"Imported\"\n)\n.\nannouncementMessage\n(\n\"This term was imported from ...\"\n)\n.\nbuild\n()\n// (4)\nWe'll create an object we can take actions on from this updater.\nIn this example, we're adding a certificate to the object.\nNote that you can chain any number of enrichments together. Here we are also adding an announcement to the asset.\nTo persist the enrichment back to the object, we must\nbuild()\nthe builder.\nAssign the result back\nRemember to assign the result of the\nbuild()\noperation back to your original object. Otherwise the result is not persisted back into any variable! (In this case we're assigning to the\nterm\nvariable back on line 5.)\nImplicit in the API calls below\nThere is nothing specific to do for this step when using the raw APIs — constructing the object is simply what you place in the payload of the API calls in the steps below.\nUpdate the asset from the object\n¶\n1.4.0\n4.0.0\nYou can then actually update the object in Atlan\n1\n:\nJava\nPython\nKotlin\nRaw REST API\nUpdate (or create) the asset\n11\n12\n13\n14\n15\n16\nAssetMutationResponse\nresponse\n=\nterm\n.\nsave\n(\nclient\n);\n// (1)\nAsset\nupdated\n=\nresponse\n.\ngetUpdatedAssets\n().\nget\n(\n0\n);\n// (2)\nGlossaryTerm\nterm\n;\nif\n(\nupdated\ninstanceof\nGlossaryTerm\n)\n{\nterm\n=\n(\nGlossaryTerm\n)\nupdated\n;\n// (3)\n}\nThe\nsave()\nmethod will either update an existing asset (if Atlan already has a term with the same name and\nqualifiedName\nin the same glossary) or create a new asset (if Atlan does not have a term with the same name in the same glossary). Because this operation will persist the asset in Atlan, you must\nprovide it an\nAtlanClient\nthrough which to connect to the tenant.\nYou can distinguish what was created or updated:\ngetCreatedAssets()\nlists assets that were created\ngetUpdatedAssets()\nlists assets that were updated\nNote that the\nsave()\nmethod always returns objects of type\nAsset\n, though.\nThe\nAsset\nclass is a superclass of all assets. So we need to cast to more specific types (like\nGlossaryTerm\n) after verifying the object that was actually returned.\nStrictly update the asset\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\ntry\n{\nAssetMutationResponse\nresponse\n=\nterm\n.\nupdateMergingCM\n(\nclient\n,\nfalse\n);\n// (1)\nAsset\nupdated\n=\nresponse\n.\ngetUpdatedAssets\n().\nget\n(\n0\n);\n// (2)\nGlossaryTerm\nterm\n;\nif\n(\nupdated\ninstanceof\nGlossaryTerm\n)\n{\nterm\n=\n(\nGlossaryTerm\n)\nupdated\n;\n// (3)\n}\n}\ncatch\n(\nNotFoundException\ne\n)\n{\n// (4)\nlog\n.\nwarn\n(\n\"No existing asset to update, so nothing changed or created.\"\n,\ne\n);\n}\nThe\nupdateMergingCM()\nmethod will only update an existing asset (if Atlan already has an asset of the same type with the same name\nqualifiedName\n).  Because this operation will persist the asset in Atlan, you must\nprovide it an\nAtlanClient\nthrough which to connect to the tenant. Depending on the update behavior you want, you could also use:\nupdateMergingCM(false)\nto only overwrite any custom metadata provided in your update (leaving anything you don't provide untouched on the existing asset), while leaving any Atlan tags on the existing asset untouched\nupdateMergingCM(true)\nto only overwrite any custom metadata provided in your update (leaving anything you don't provide untouched on the existing asset), while replacing any Atlan tags on the existing asset\nupdateReplacingCM(false)\nto overwrite all custom metadata on the existing asset with what you're providing in your update, while leaving any Atlan tags on the existing asset untouched\nupdateReplacingCM(true)\nto overwrite all custom metadata on the existing asset with what you're providing in your update, while replacing any Atlan tags on the existing asset\nYou can distinguish what was created or updated:\ngetUpdatedAssets()\nlists assets that were updated\nNote that the\nupdate...()\nmethods always returns objects of type\nAsset\n, though.\nThe\nAsset\nclass is a superclass of all assets. So we need to cast to more specific types (like\nGlossaryTerm\n) after verifying the object that was actually returned.\nSince the\nupdate...()\nmethods strictly update (and never create) an asset, if the asset you are trying to update does not exist the operation will throw a\nNotFoundException\n.\nUpdate (or create) the asset\n18\n19\n20\nresponse\n=\nclient\n.\nasset\n.\nsave\n(\nterm\n)\n# (1)\nif\nupdated\n:=\nresponse\n.\nassets_updated\n(\nasset_type\n=\nAtlasGlossaryTerm\n):\n# (2)\nterm\n=\nupdated\n[\n0\n]\n# (3)\nThe\nsave(term)\nmethod will either update an existing asset (if Atlan already has a term with the same name and\nqualifiedName\nin the same glossary) or (create a new asset, if Atlan does not have a term with the same name in the same glossary).\nYou can distinguish what was created or updated:\nassets_created(asset_type = AtlasGlossaryType)\nreturns a list assets of the specified type that were created.\nassets_updated(asset_type = AtlasGlossaryType)\nreturns a list assets of the specified type that were updated.\nIf the returned list is not empty, get the term that was updated.\nStrictly update the asset\n18\n19\n20\n21\n22\n23\ntry\n:\nresponse\n=\nclient\n.\nasset\n.\nupdate_merging_cm\n(\nterm\n)\n# (1)\nif\nupdated\n:=\nresponse\n.\nassets_updated\n(\nasset_type\n=\nAtlasGlossaryTerm\n):\n# (2)\nterm\n=\nupdated\n[\n0\n]\nexcept\nNotFoundError\n:\n# (3)\nprint\n(\n\"No existing asset to update, so nothing changed or created.\"\n)\nThe\nupdate_merging_cm()\nmethod will only update an existing asset (if Atlan already has an asset of the same type with the same name\nqualified_name\n). Depending on the update behavior you want, you could also use:\nupdate_merging_cm(replace_atlan_tags=False)\nto only overwrite any custom metadata provided in your update (leaving anything you don't provide untouched on the existing asset), while leaving any Atlan tags on the existing asset untouched\nupdate_merging_cm(replace_atlan_tags=True)\nto only overwrite any custom metadata provided in your update (leaving anything you don't provide untouched on the existing asset), while replacing any Atlan tags on the existing asset\nupdate_replacing_cm(replace_atlan_tags=False)\nto overwrite all custom metadata on the existing asset with what you're providing in your update, while leaving any Atlan tags on the existing asset untouched\nupdate_replacing_cm(replace_atlan_tags=True)\nto overwrite all custom metadata on the existing asset with what you're providing in your update, while replacing any Atlan tags on the existing asset\nYou can distinguish what was created or updated:\nassets_updated(asset_type = AtlasGlossaryType)\nreturns a list assets of the specified type that were updated.\nSince the\nupdate...()\nmethods strictly update (and never create) an asset, if the asset you are trying to update does not exist the operation will throw a\nNotFoundError\n.\nUpdate (or create) the asset\n13\n14\n15\nval\nresponse\n=\nterm\n.\nsave\n(\nclient\n)\n// (1)\nval\nupdated\n=\nresponse\n.\nupdatedAssets\n[\n0\n]\n// (2)\nval\nterm\n=\nif\n(\nupdated\nis\nGlossaryTerm\n)\nupdated\nelse\nnull\n// (3)\nThe\nsave()\nmethod will either update an existing asset (if Atlan already has a term with the same name and\nqualifiedName\nin the same glossary) or create a new asset (if Atlan does not have a term with the same name in the same glossary). Because this operation will persist the asset in Atlan, you must\nprovide it an\nAtlanClient\nthrough which to connect to the tenant.\nYou can distinguish what was created or updated:\ncreatedAssets\nlists assets that were created\nupdatedAssets\nlists assets that were updated\nNote that the\nsave()\nmethod always returns objects of type\nAsset\n, though.\nThe\nAsset\nclass is a superclass of all assets. So we need to cast to more specific types (like\nGlossaryTerm\n) after verifying the object that was actually returned.\nStrictly update the asset\n13\n14\n15\n16\n17\n18\n19\ntry\n{\nval\nresponse\n=\nterm\n.\nupdateMergingCM\n(\nclient\n,\nfalse\n)\n// (1)\nval\nupdated\n=\nresponse\n.\nupdatedAssets\n[\n0\n]\n// (2)\nval\nterm\n=\nif\n(\nupdated\nis\nGlossaryTerm\n)\nupdated\nelse\nnull\n// (3)\n}\ncatch\n(\ne\n:\nNotFoundException\n)\n{\n// (4)\nlog\n.\nwarn\n(\n\"No existing asset to update, so nothing changed or created.\"\n,\ne\n)\n}\nThe\nupdateMergingCM()\nmethod will only update an existing asset (if Atlan already has an asset of the same type with the same name\nqualifiedName\n). Because this operation will persist the asset in Atlan, you must\nprovide it an\nAtlanClient\nthrough which to connect to the tenant. Depending on the update behavior you want, you could also use:\nupdateMergingCM(false)\nto only overwrite any custom metadata provided in your update (leaving anything you don't provide untouched on the existing asset), while leaving any Atlan tags on the existing asset untouched\nupdateMergingCM(true)\nto only overwrite any custom metadata provided in your update (leaving anything you don't provide untouched on the existing asset), while replacing any Atlan tags on the existing asset\nupdateReplacingCM(false)\nto overwrite all custom metadata on the existing asset with what you're providing in your update, while leaving any Atlan tags on the existing asset untouched\nupdateReplacingCM(true)\nto overwrite all custom metadata on the existing asset with what you're providing in your update, while replacing any Atlan tags on the existing asset\nYou can distinguish what was created or updated:\ngetUpdatedAssets()\nlists assets that were updated\nNote that the\nupdate...()\nmethods always returns objects of type\nAsset\n, though.\nThe\nAsset\nclass is a superclass of all assets. So we need to cast to more specific types (like\nGlossaryTerm\n) after verifying the object that was actually returned.\nSince the\nupdate...()\nmethods strictly update (and never create) an asset, if the asset you are trying to update does not exist the operation will throw a\nNotFoundException\n.\nPOST /api/meta/entity/bulk\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n{\n\"entities\"\n:\n[\n// (1)\n{\n\"typeName\"\n:\n\"AtlasGlossaryTerm\"\n,\n// (2)\n\"attributes\"\n:\n{\n\"name\"\n:\n\"Example Term\"\n,\n// (3)\n\"qualifiedName\"\n:\n\"gsNccqJraDZqM6WyGP3ea@FzCMyPR2LxkPFgr8eNGrq\"\n,\n// (4)\n\"anchor\"\n:\n{\n// (5)\n\"typeName\"\n:\n\"AtlasGlossary\"\n,\n\"guid\"\n:\n\"b4113341-251b-4adc-81fb-2420501c30e6\"\n},\n\"certificateStatus\"\n:\n\"VERIFIED\"\n,\n// (6)\n\"announcementType\"\n:\n\"information\"\n,\n// (7)\n\"announcementTitle\"\n:\n\"Imported\"\n,\n\"announcementMessage\"\n:\n\"This term was imported from ...\"\n}\n}\n]\n}\nAll assets must be wrapped in an\nentities\narray.\nYou must provide the exact type name for the asset (case-sensitive). For a term, this is\nAtlasGlossaryTerm\n.\nYou must provide the exact name of the existing asset (case-sensitive). (Unless you want to change its name, in which case you can provide the new name instead.)\nYou must provide the exact\nqualifiedName\nof the existing asset (case-sensitive).\nMust exactly match the\nqualifiedName\nof an existing asset\nIf this does not exactly match the\nqualifiedName\nof an existing asset, the API call will instead\ncreate a new asset\nrather than updating an existing one.\nFor most assets, you do\nnot\nneed to re-specify the parent object for an update. However, for glossary assets (like terms), you are required to re-specify the parent glossary.\nIn this example, we're adding a certificate to the object.\nNote that you can include any number of enrichments together. Here we are also adding an announcement to the asset.\nCase-sensitive, exact match\nIf you use a different capitalization or spelling for the\nqualifiedName\n, you may accidentally\ncreate\na new asset rather than updating the existing one.\n2\nRemove information from an asset\n¶\n1.4.0\n4.0.0\nAs mentioned in\nEnrich before updating\nsection, only the information in your request will be updated on the object. But what if you want to\nremove\nsome information that already exists on the asset in Atlan?\nJava\nPython\nKotlin\nRaw REST API\nEnrich and update the asset\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\nGlossaryTerm\nterm\n=\ntermUpdater\n// (1)\n.\nremoveCertificate\n()\n// (2)\n.\nremoveAnnouncement\n()\n// (3)\n.\nbuild\n();\n// (4)\nAssetMutationResponse\nresponse\n=\nterm\n.\nsave\n(\nclient\n);\n// (5)\nAsset\nupdated\n=\nresponse\n.\ngetUpdatedAssets\n().\nget\n(\n0\n);\n// (6)\nGlossaryTerm\nterm\n;\nif\n(\nupdated\ninstanceof\nGlossaryTerm\n)\n{\nterm\n=\n(\nGlossaryTerm\n)\nupdated\n;\n// (7)\n}\nWe'll create an object we can take actions on from this updater.\nIn this example, we'll remove any existing certificate from the object in Atlan.\nNote that you can chain any number of enrichments together. Here we are also removing any announcement from the asset.\nTo persist the enrichment back to the object, we must\nbuild()\nthe builder.\nAssign the result back\nRemember to assign the result of the\nbuild()\noperation back to your original object. Otherwise the result is not persisted back into any variable! (In this case we're assigning to the\nterm\nvariable back on line 5.)\nThe\nsave()\nmethod will either:\nUpdate an existing asset, if Atlan already has a term with the same name and\nqualifiedName\nin the same glossary.\nCreate a new asset, if Atlan does not have a term with the same name in the same glossary.\nBecause this operation will persist the asset in Atlan, you must\nprovide it an\nAtlanClient\nthrough which to connect to the tenant.\nYou can distinguish what was created or updated:\ngetCreatedAssets()\nlists assets that were created\ngetUpdatedAssets()\nlists assets that were updated\nNote that the\nsave()\nmethod always returns objects of type\nAsset\n, though.\nThe\nAsset\nclass is a superclass of all assets. So we need to cast to more specific types (like\nGlossaryTerm\n) after verifying the object that was actually returned.\nEnrich and update the asset\n11\n12\n13\n14\n15\nterm\n.\nremove_certificate\n()\n# (1)\nterm\n.\nremove_announcement\n()\n# (2)\nresponse\n=\nclient\n.\nasset\n.\nsave\n(\nterm\n)\nif\nupdated\n:=\nresponse\n.\nassets_updated\n(\nasset_type\n=\nAtlasGlossaryTerm\n):\nterm\n=\nupdated\n[\n0\n]\nIn this example we will remove an existing certificate from any existing certificate from the object.\nIn this example we will remove any existing announcement from the object.\nEnrich and update the asset\n7\n8\n9\n10\n11\n12\n13\nvar\nterm\n=\ntermUpdater\n// (1)\n.\nremoveCertificate\n()\n// (2)\n.\nremoveAnnouncement\n()\n// (3)\n.\nbuild\n()\n// (4)\nval\nresponse\n=\nterm\n.\nsave\n(\nclient\n)\n// (5)\nval\nupdated\n=\nresponse\n.\nupdatedAssets\n[\n0\n]\n// (6)\nterm\n=\nif\n(\nupdated\nis\nGlossaryTerm\n)\nupdated\nelse\nnull\n// (7)\nWe'll create an object we can take actions on from this updater.\nIn this example, we'll remove any existing certificate from the object in Atlan.\nNote that you can chain any number of enrichments together. Here we are also removing any announcement from the asset.\nTo persist the enrichment back to the object, we must\nbuild()\nthe builder.\nAssign the result back\nRemember to assign the result of the\nbuild()\noperation back to your original object. Otherwise the result is not persisted back into any variable! (In this case we're assigning to the\nterm\nvariable back on line 5.)\nThe\nsave()\nmethod will either:\nUpdate an existing asset, if Atlan already has a term with the same name and\nqualifiedName\nin the same glossary.\nCreate a new asset, if Atlan does not have a term with the same name in the same glossary.\nBecause this operation will persist the asset in Atlan, you must\nprovide it an\nAtlanClient\nthrough which to connect to the tenant.\nYou can distinguish what was created or updated:\ncreatedAssets\nlists assets that were created\nupdatedAssets\nlists assets that were updated\nNote that the\nsave()\nmethod always returns objects of type\nAsset\n, though.\nThe\nAsset\nclass is a superclass of all assets. So we need to cast to more specific types (like\nGlossaryTerm\n) after verifying the object that was actually returned.\nPOST /api/meta/entity/bulk\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n{\n\"entities\"\n:\n[\n// (1)\n{\n\"typeName\"\n:\n\"AtlasGlossaryTerm\"\n,\n// (2)\n\"attributes\"\n:\n{\n\"name\"\n:\n\"Example Term\"\n,\n// (3)\n\"qualifiedName\"\n:\n\"gsNccqJraDZqM6WyGP3ea@FzCMyPR2LxkPFgr8eNGrq\"\n,\n// (4)\n\"anchor\"\n:\n{\n// (5)\n\"typeName\"\n:\n\"AtlasGlossary\"\n,\n\"guid\"\n:\n\"b4113341-251b-4adc-81fb-2420501c30e6\"\n},\n\"certificateStatus\"\n:\nnull\n,\n// (6)\n\"certificateStatusMessage\"\n:\nnull\n,\n\"announcementType\"\n:\nnull\n,\n// (7)\n\"announcementTitle\"\n:\nnull\n,\n\"announcementMessage\"\n:\nnull\n}\n}\n]\n}\nAll assets must be wrapped in an\nentities\narray.\nYou must provide the exact type name for the asset (case-sensitive). For a term, this is\nAtlasGlossaryTerm\n.\nYou must provide the exact name of the existing asset (case-sensitive). (Unless you want to change its name, in which case you can provide the new name instead.)\nYou must provide the exact\nqualifiedName\nof the existing asset (case-sensitive).\nMust exactly match the\nqualifiedName\nof an existing asset\nIf this does not exactly match the\nqualifiedName\nof an existing asset, the API call will instead\ncreate a new asset\nrather than updating an existing one.\nFor most assets, you do\nnot\nneed to re-specify the parent object for an update. However, for glossary assets (like terms), you are required to re-specify the parent glossary.\nIn this example, we're removing any existing certificate information from the object in Atlan (by sending\nnull\n).\nNote that you can include any number of enrichments together. Here we are also removing any announcement from the asset.\nAtlan automatically detects changes to determine whether to create or update an asset — see the\nImportance of identifiers\nfor a more detailed explanation. To strictly update (and avoid creating) an asset, you must first look for the existing asset and only if found proceed with your update. When the SDKs provide such strict update functionality, this is what they are doing behind-the-scenes. Be aware that this will impact performance, so you should only do this where strictly necessary for your logic.\n↩\nThis is because Atlan uses the\nexact\nqualifiedName\nto determine whether it should do an update. For a more detailed explanation, see the\nImportance of identifiers\n.\n↩\n2022-09-14\n2024-12-11\nWas this page helpful?\nThanks for your feedback!\nThanks for your feedback! Help us improve this page by using our\nfeedback form\nto provide us with more information.\nBack to top\nCookie consent\nWe use cookies to:\nAnonymously measure page views, and\nAllow you to give us one-click feedback on any page.\nWe do\nnot\ncollect or store:\nAny personally identifiable information.\nAny information for any (re)marketing purposes.\nWith your consent, you're helping us to make our documentation better 💙\nGoogle Analytics\nAccept\nReject\nManage settings",
  "source_type": "sdk"
}