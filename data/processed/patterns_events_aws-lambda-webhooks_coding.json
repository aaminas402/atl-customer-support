{
  "source_url": "patterns_events_aws-lambda-webhooks_coding.html",
  "text": "Code your logic - Developer\nSkip to content\nCoding your logic\nÂ¶\nWhat events you want to process and how you want to process them is up to you.\nWe have tried to make writing this logic as simple as possible via the SDKs:\nJava\nPython\nIn Java, create a new class that implements the following from the\nJava SDK\n:\nExtend the\ncom.atlan.events.AbstractLambdaHandler\nclass.\nImplement the\ncom.atlan.events.AtlanEventHandler\ninterface.\nThe\nAbstractLambdaHandler\nclass handles receiving and parsing the event through the AWS Lambda function, and passing it along to your logic for processing. The\nAtlanEventHandler\ninterface defines 5 methods that are executed in logical sequence to carry out your event-handling:\nvalidatePrerequisites()\nvalidates the event contains information you expect and intend to process.\ngetCurrentState()\nretrieves the current state of the asset in the event from Atlan. This limits the possibility you are working against stale data.\ncalculateChanges()\nis where you will implement the majority of your logic. This is where you look up any additional information, make any changes to assets, create notifications in external systems, and so on.\nEnsure idempotency\nYou should only return assets from this method that have actually changed, to ensure idempotency. If you blindly return every asset of interest every time from this method, you may end up with an infinite loop of picking up an event, sending back a change to Atlan, which generates another event, this handler sends back another change, and so on ad infinitum.\nThe\nhasChanges()\nmethod below can be helpful to think through how to detect what has actually changed and thus needs to be sent back to Atlan.\nhasChanges()\nis a convenience method you can implement to determine whether an asset has changed or not. You would typically call it from within your\ncalculateChanges()\nimplementation above.\nupsertChanges()\ntakes any of the changed assets from the\ncalculateChanges()\nmethod and actually sends these back to Atlan for persistence. (Each such change may then generate subsequent events that either this or other handlers can then pickup.)\nExample: reverting verified assets that have no description or owner\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\nimport\ncom.atlan.AtlanClient\n;\nimport\ncom.atlan.events.AbstractLambdaHandler\n;\nimport\ncom.atlan.events.AtlanEventHandler\n;\nimport\ncom.atlan.exception.AtlanException\n;\nimport\ncom.atlan.exception.ErrorCode\n;\nimport\ncom.atlan.exception.NotFoundException\n;\nimport\ncom.atlan.model.assets.Asset\n;\nimport\ncom.atlan.model.enums.CertificateStatus\n;\nimport\njava.util.Collection\n;\nimport\njava.util.Collections\n;\nimport\njava.util.List\n;\nimport\njava.util.Set\n;\nimport\norg.slf4j.Logger\n;\npublic\nclass\nVerificationEnforcer\n// (1)\nextends\nAbstractLambdaHandler\n// (2)\nimplements\nAtlanEventHandler\n{\n// (3)\nprivate\nstatic\nfinal\nList\n<\nString\n>\nREQUIRED_ATTRS\n=\nList\n.\nof\n(\n\"description\"\n,\n\"userDescription\"\n,\n\"ownerUsers\"\n,\n\"ownerGroups\"\n,\n\"certificateStatus\"\n);\n// (4)\n@Override\n// (5)\npublic\nAsset\ngetCurrentState\n(\nAtlanClient\nclient\n,\nAsset\nfromEvent\n,\nLogger\nlog\n)\nthrows\nAtlanException\n{\nAsset\nasset\n=\nAtlanEventHandler\n.\ngetCurrentViewOfAsset\n(\n// (6)\nfromEvent\n,\nREQUIRED_ATTRS\n,\nfalse\n,\nfalse\n);\nif\n(\nasset\n==\nnull\n)\n{\nthrow\nnew\nNotFoundException\n(\nErrorCode\n.\nASSET_NOT_FOUND_BY_QN\n,\nfromEvent\n.\ngetQualifiedName\n(),\nfromEvent\n.\ngetTypeName\n());\n}\nreturn\nasset\n;\n}\n@Override\n// (7)\npublic\nCollection\n<\nAsset\n>\ncalculateChanges\n(\nAsset\nasset\n,\nLogger\nlog\n)\nthrows\nAtlanException\n{\nif\n(\nasset\n.\ngetCertificateStatus\n()\n==\nCertificateStatus\n.\nVERIFIED\n)\n{\nif\n(\n!\nAtlanEventHandler\n.\nhasDescription\n(\nasset\n)\n||\n!\nAtlanEventHandler\n.\nhasOwner\n(\nasset\n))\n{\nreturn\nSet\n.\nof\n(\nasset\n.\ntrimToRequired\n()\n// (8)\n.\ncertificateStatus\n(\nCertificateStatus\n.\nDRAFT\n)\n.\ncertificateStatusMessage\n(\nENFORCEMENT_MESSAGE\n)\n.\nbuild\n());\n}\nelse\n{\nlog\n.\ninfo\n(\n\"Asset has all required information present to be verified, no enforcement required: {}\"\n,\nasset\n.\ngetQualifiedName\n());\n}\n}\nelse\n{\nlog\n.\ninfo\n(\n\"Asset is no longer verified, no enforcement action to consider: {}\"\n,\nasset\n.\ngetQualifiedName\n());\n}\nreturn\nCollections\n.\nemptySet\n();\n}\n// (9)\nprivate\nstatic\nfinal\nVerificationEnforcer\nINSTANCE\n=\ncreateInstance\n();\nprivate\nstatic\nVerificationEnforcer\ncreateInstance\n()\n{\nreturn\nnew\nVerificationEnforcer\n();\n}\npublic\nstatic\nVerificationEnforcer\ngetInstance\n()\n{\nreturn\nINSTANCE\n;\n}\npublic\nVerificationEnforcer\n()\n{\n// (10)\nsuper\n(\nVerificationEnforcer\n.\ngetInstance\n());\n}\n}\nYou can package your event handler with whatever name you want.\nEnsure that it extends the\ncom.atlan.events.AbstractLambdaHandler\nclass.\nEnsure that it also implements the\ncom.atlan.events.AtlanEventHandler\nclass.\nOf course you can set up any of your own variables. In this example, since we want to validate certain information is present on the asset, we're defining a list of those attributes we want to check on the asset.\nMost methods in\nAtlanEventHandler\nprovide a default implementation that you may be able to reuse (like\nvalidatePrerequisites()\nin this example), but you can always override the default implementation as well.\nAtlanEventHandler\nalso provides a number of static methods for common actions, such as an efficient way of retrieving the current view of an asset with a minimal set of information.\nBy breaking down the logic into these 5 different methods, you can more precisely think through the logic of how to handle your events. In this example, we only need to consider changing an asset if:\nIt is currently verified, and\nit is missing either a description or an owner\nDuring event-handling you may want to change several assets. For example, you may want to look at lineage and change multiple upstream or downstream assets. Hence the method allows returning any collection of assets.\nThe functionality in this example only needs to potentially modify the single asset in the event: specifically changing its certificate back to\nDRAFT\nand leaving an enforcement message, if it should not have been verified in the first place.\nFor efficiency, you may want to create a singleton for this class for reuse in the next step.\nAll you need to then do to \"register\" this class to handle events through the Lambda function is define a default constructor that sends your class up to the\nAbstractLambdaHandler\nsuperclass. The superclass will then take care of everything else.\nIn Python, create a module (file) that extends the following from the\nPython SDK\n:\nDefines a new class, that extends the\npyatlan.events.atlan_event_handler.AtlanEventHandler\nclass.\nDefines a new function\nlambda_handler(event, context)\nthat calls the\npyatlan.events.atlan_lambda_handler.process_event\nfunction.\nThe\nlambda_handler\nfunction is necessary to receive the event from the AWS Lambda function, but then only needs to pass it off to the\nprocess_event\nfunction for parsing and processing using your logic. The\nAtlanEventHandler\nsuperclass defines 5 methods that are executed in logical sequence (by\nprocess_event\n) to carry out your event-handling:\nvalidate_prerequisites()\nvalidates the event contains information you expect and intend to process.\nget_current_state()\nretrieves the current state of the asset in the event from Atlan. This limits the possibility you are working against stale data.\ncalculate_changes()\nis where you will implement the majority of your logic. This is where you look up any additional information, make any changes to assets, create notifications in external systems, and so on.\nEnsure idempotency\nYou should only return assets from this method that have actually changed, to ensure idempotency. If you blindly return every asset of interest every time from this method, you may end up with an infinite loop of picking up an event, sending back a change to Atlan, which generates another event, this handler sends back another change, and so on ad infinitum.\nThe\nhas_changes()\nmethod below can be helpful to think through how to detect what has actually changed and thus needs to be sent back to Atlan.\nhas_changes()\nis a convenience method you can implement to determine whether an asset has changed or not. You would typically call it from within your\ncalculate_changes()\nimplementation above.\nupsert_changes()\ntakes any of the changed assets from the\ncalculate_changes()\nmethod and actually sends these back to Atlan for persistence. (Each such change may then generate subsequent events that either this or other handlers can then pickup.)\nExample: reverting verified assets that have no description or owner\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\nfrom\ntyping\nimport\nList\n,\nOptional\nfrom\npyatlan.client.atlan\nimport\nAtlanClient\nfrom\npyatlan.events.atlan_lambda_handler\nimport\nprocess_event\nfrom\npyatlan.events.atlan_event_handler\nimport\n(\nAtlanEventHandler\n,\nget_current_view_of_asset\n,\nhas_description\n,\nhas_owner\n,\nhas_lineage\n,\n)\nfrom\npyatlan.model.assets\nimport\nAsset\nfrom\npyatlan.model.enums\nimport\nCertificateStatus\nREQUIRED_ATTRS\n=\n[\n# (1)\n\"description\"\n,\n\"userDescription\"\n,\n\"ownerUsers\"\n,\n\"ownerGroups\"\n,\n\"certificateStatus\"\n,\n]\nENFORCEMENT_MESSAGE\n=\n(\n\"To be verified, an asset must have a description, at least one owner, and lineage.\"\n)\nclient\n=\nAtlanClient\n()\n# (2)\nclass\nVerificationEnforcer\n(\nAtlanEventHandler\n):\n# (3)\n# (4)\ndef\nget_current_state\n(\nself\n,\nfrom_event\n:\nAsset\n)\n->\nOptional\n[\nAsset\n]:\nreturn\nget_current_view_of_asset\n(\nself\n.\nclient\n,\nfrom_event\n,\nREQUIRED_ATTRS\n)\n# (5)\n# (6)\ndef\ncalculate_changes\n(\nself\n,\nasset\n:\nAsset\n)\n->\nList\n[\nAsset\n]:\nif\nasset\n.\ncertificate_status\n==\nCertificateStatus\n.\nVERIFIED\n:\nif\n(\nnot\nhas_description\n(\nasset\n)\nor\nnot\nhas_owner\n(\nasset\n)\nor\nnot\nhas_lineage\n(\nasset\n)\n):\ntrimmed\n=\nasset\n.\ntrim_to_required\n()\ntrimmed\n.\ncertificate_status\n=\nCertificateStatus\n.\nDRAFT\ntrimmed\n.\ncertificate_status_message\n=\nENFORCEMENT_MESSAGE\nreturn\n[\ntrimmed\n]\n# (7)\nelse\n:\nprint\n(\nf\n\"Asset has all required information present to be verified, no enforcement required:\n{\nasset\n.\nqualified_name\n}\n\"\n)\nelse\n:\nprint\n(\nf\n\"Asset is no longer verified, no enforcement action to consider:\n{\nasset\n.\nqualified_name\n}\n\"\n)\nreturn\n[]\ndef\nlambda_handler\n(\nevent\n,\ncontext\n):\n# (8)\nprocess_event\n(\nLambdaEnforcer\n(\nclient\n),\nevent\n,\ncontext\n)\nYou can of course set up any of your own variables. In this example, since we want to validate certain information is present on the asset, we're defining a list of those attributes we want to check on the asset.\nYou will need to initialize an AtlanClient, to interact with Atlan. (This will auto-configure based on those environment variables you set up earlier.)\nYou can package your event handler with whatever name you want. Just ensure it extends the\npyatlan.events.atlan_event_handler.AtlanEventHandler\nclass.\nMost methods in\nAtlanEventHandler\nprovide a default implementation that you may be able to reuse (like\nvalidate_prerequisites()\nin this example), but you can always override the default implementation as well.\nAtlanEventHandler\nalso provides a number of utility methods for common actions, such as an efficient way of retrieving the current view of an asset with a minimal set of information.\nBy breaking down the logic into these 5 different methods, you can more precisely think through the logic of how to handle your events. In this example, we only need to consider changing an asset if:\nIt is currently verified, and\nit is missing either a description or an owner\nDuring event-handling you may want to change several assets. For example, you may want to look at lineage and change multiple upstream or downstream assets. Hence the method allows returning any collection of assets.\nThe functionality in this example only needs to potentially modify the single asset in the event: specifically changing its certificate back to\nDRAFT\nand leaving an enforcement message, if it should not have been verified in the first place.\nAll you need to then do to \"register\" this class to handle events through the Lambda function is define a\nlambda_handler(event, context)\nfunction that sends your class and client to the\nprocess_event\nfunction - it will then take care of everything else.\n2023-06-23\n2024-10-01\nWas this page helpful?\nThanks for your feedback!\nThanks for your feedback! Help us improve this page by using our\nfeedback form\nto provide us with more information.\nBack to top\nCookie consent\nWe use cookies to:\nAnonymously measure page views, and\nAllow you to give us one-click feedback on any page.\nWe do\nnot\ncollect or store:\nAny personally identifiable information.\nAny information for any (re)marketing purposes.\nWith your consent, you're helping us to make our documentation better ðŸ’™\nGoogle Analytics\nAccept\nReject\nManage settings",
  "source_type": "sdk"
}