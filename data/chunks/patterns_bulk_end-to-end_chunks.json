[
  {
    "content": "End-to-end bulk update - Developer\nSkip to content\nEnd-to-end bulk update\n¶\nRunning example\nTo walk through this using an example, and to compare and contrast the approaches, imagine you want to:\nMark all views (including materialized views) in a particular schema as verified, unless they already have some certificate.\nChange the owner of the same views.\nStep-by-step\n¶\nThe usual end-to-end pattern for updating many assets efficiently involves three steps:\nFinding the assets you want to update.\nApplying your updates to each asset (in-memory).\nSending those changes to Atlan (in batches).\nYou can do each of these steps in sequence, for example:\n1. Find the assets\n¶\n1.4.0\n1.1.0\nYou start by first finding the assets you want to update. This is usually best done through a\nsearch\n. (For other common examples, have a look at the\nsearch snippets\n.)\nJava\nPython\nKotlin\nRaw REST API\nExample: get all views in a schema\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\nString\nschemaQN\n=\n\"default/snowflake/1662194632/MYDB/MY_SCH\"\n;\n// (1)\nIndexSearchRequest\nfindViews\n=\nclient\n.\nassets\n.\nselect\n()\n// (2)\n.\nwhere\n(\nAsset\n.\nQUALIFIED_NAME\n.\nstartsWith\n(\nschemaQN\n))\n// (3)\n.\nwhere\n(\nAsset\n.\nTYPE_NAME\n.\nin\n(\nList\n.\nof\n(\nView",
    "metadata": {
      "source_url": "patterns_bulk_end-to-end.html",
      "source_type": "sdk",
      "file": "patterns_bulk_end-to-end.json",
      "chunk_id": 0
    }
  },
  {
    "content": ";\n// (1)\nIndexSearchRequest\nfindViews\n=\nclient\n.\nassets\n.\nselect\n()\n// (2)\n.\nwhere\n(\nAsset\n.\nQUALIFIED_NAME\n.\nstartsWith\n(\nschemaQN\n))\n// (3)\n.\nwhere\n(\nAsset\n.\nTYPE_NAME\n.\nin\n(\nList\n.\nof\n(\nView\n.\nTYPE_NAME\n,\nMaterializedView\n.\nTYPE_NAME\n)))\n// (4)\n.\nwhereNot\n(\nAsset\n.\nCERTIFICATE_STATUS\n.\nhasAnyValue\n())\n// (5)\n.\npageSize\n(\n100\n)\n// (6)\n.\nincludeOnResults\n(\nAsset\n.\nDESCRIPTION\n)\n// (7)\n.\nincludeOnResults\n(\nAsset\n.\nCERTIFICATE_STATUS\n)\n.\nincludeOnResults\n(\nAsset\n.\nOWNER_USERS\n)\n.\ntoRequest\n();\n// (8)\nIndexSearchResponse\nresponse\n=\nfindViews\n.\nsearch\n();\n// (9)\nThe\nqualifiedName\nof every view starts with the\nqualifiedName\nof its parent (schema), so we can limit the results to a particular schema by using the\nqualifiedName\n.\nTo start building up a query with multiple conditions, you can use the\nselect()\nhelper on any client's\nassets\nmember.\nYou can chain\nwhere()\nmethods to define all the conditions the search results must match. You can use the static constants within any given type to select a particular attribute (like\nQUALIFIED_NAME\nin this example), and then limit results to only those assets whose\nqualifiedName\nstarts with the\nqualifiedName\nof the schema (by using the",
    "metadata": {
      "source_url": "patterns_bulk_end-to-end.html",
      "source_type": "sdk",
      "file": "patterns_bulk_end-to-end.json",
      "chunk_id": 1
    }
  },
  {
    "content": "QUALIFIED_NAME\nin this example), and then limit results to only those assets whose\nqualifiedName\nstarts with the\nqualifiedName\nof the schema (by using the\nstartsWith()\npredicate). In this example, that means only assets that are within this particular schema will be returned as results.\nSince there could be tables, views, materialized views and columns in this schema — but you only want views and materialized views — you can use the\nAsset.TYPE_NAME.in()\nmethod to restrict results to only views and materialized views.\nSince you only want to update views that do not already have a certificate, you can further limit the results using the\nwhereNot()\nmethod. This will exclude any assets where a certificate already\nhasAnyValue()\n.\nHere you can play around with different page sizes, to further limit API calls by retrieving more results per page.\nAdd as many attributes as needed. Each attribute you add here will ensure that detail is included in each search result. So in this example, every view will include its description, certificate, and individual owners. (Limit these attributes to the minimum you need about each view to do your intended work.)",
    "metadata": {
      "source_url": "patterns_bulk_end-to-end.html",
      "source_type": "sdk",
      "file": "patterns_bulk_end-to-end.json",
      "chunk_id": 2
    }
  },
  {
    "content": "You can translate the object you've built up into various outputs, for example immediately calculating a count of how many results match or streaming them directly for processing. In this case, the\ntoRequest()\nmethod will give us the resulting set of criteria back as a complete index search request.\nYou can then execute the search based on the request.\nExample: get all views in a schema\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\nfrom\npyatlan.client.atlan\nimport\nAtlanClient\nfrom\npyatlan.client.asset\nimport\nBatch\nfrom\npyatlan.errors\nimport\nAtlanError\nfrom\npyatlan.model.enums\nimport\nCertificateStatus\nfrom\npyatlan.model.fluent_search\nimport\nCompoundQuery\n,\nFluentSearch\nfrom\npyatlan.model.assets\nimport\nAsset\n,\nView\n,\nMaterialisedView\nclient\n=\nAtlanClient\n()\nschema_qualified_name\n=\n\"default/snowflake/1662194632/MYDB/MY_SCH\"\n# (1)\nfind_views\n=\n(\nFluentSearch\n()\n# (2)\n.\nwhere\n(\nAsset\n.\nQUALIFIED_NAME\n.\nstartswith\n(\nschema_qualified_name\n))\n# (3)\n.\nwhere\n(\nCompoundQuery\n.\nasset_types\n([\nView\n,\nMaterialisedView\n]))\n# (4)\n.\nwhere\n(\nCompoundQuery\n.\nactive_assets\n())\n.\nwhere_not\n(\nAsset\n.\nCERTIFICATE_STATUS\n.\nhas_any_value\n())\n# (5)\n.\npage_size\n(\n100\n)\n# (6)\n.\ninclude_on_results",
    "metadata": {
      "source_url": "patterns_bulk_end-to-end.html",
      "source_type": "sdk",
      "file": "patterns_bulk_end-to-end.json",
      "chunk_id": 3
    }
  },
  {
    "content": "([\nView\n,\nMaterialisedView\n]))\n# (4)\n.\nwhere\n(\nCompoundQuery\n.\nactive_assets\n())\n.\nwhere_not\n(\nAsset\n.\nCERTIFICATE_STATUS\n.\nhas_any_value\n())\n# (5)\n.\npage_size\n(\n100\n)\n# (6)\n.\ninclude_on_results\n(\nAsset\n.\nDESCRIPTION\n)\n# (7)\n.\ninclude_on_results\n(\nAsset\n.\nCERTIFICATE_STATUS\n)\n.\ninclude_on_results\n(\nAsset\n.\nOWNER_USERS\n)\n)\n.\nto_request\n()\n# (8)\nresponse\n=\nclient\n.\nasset\n.\nsearch\n(\nfind_views\n)\n# (9)\nThe\nqualified_name\nof every view starts with the\nqualified_name\nof its parent (schema), so we can limit the results to a particular schema by using the\nqualified_name\n.\nTo start building up a query with multiple conditions, you can use a\nFluentSearch()\nobject.\nYou can chain\nwhere()\nmethods to define all the conditions the search results must match. You can use the class variables within any given type to select a particular attribute (like\nQUALIFIED_NAME\nin this example), and then limit results to only those assets whose\nqualified_name\nstarts with the\nqualified_name\nof the schema (by using the\nstartswith()\npredicate). In this example, that means only assets that are within this particular schema will be returned as results.",
    "metadata": {
      "source_url": "patterns_bulk_end-to-end.html",
      "source_type": "sdk",
      "file": "patterns_bulk_end-to-end.json",
      "chunk_id": 4
    }
  },
  {
    "content": "starts with the\nqualified_name\nof the schema (by using the\nstartswith()\npredicate). In this example, that means only assets that are within this particular schema will be returned as results.\nSince there could be tables, views, materialized views and columns in this schema — but you only want views and materialized views — you can use the\nCompoundQuery.asset_types()\nhelper method to restrict results to only views and materialized views.\nSince you only want to update views that do not already have a certificate, you can further limit the results using the\nwhere_not()\nmethod. This will exclude any assets where a certificate already\nhas_any_value()\n.\nHere you can play around with different page sizes, to further limit API calls by retrieving more results per page.\nAdd as many attributes as needed. Each attribute you add here will ensure that detail is included in each search result. So in this example, every view will include its description, certificate, and individual owners. (Limit these attributes to the minimum you need about each view to do your intended work.)",
    "metadata": {
      "source_url": "patterns_bulk_end-to-end.html",
      "source_type": "sdk",
      "file": "patterns_bulk_end-to-end.json",
      "chunk_id": 5
    }
  },
  {
    "content": "You can translate the object you've built up into various outputs, for example immediately calculating a count of how many results match or executing the query to start processing results directly. In this case, the\nto_request()\nmethod will give us the resulting set of criteria back as a complete index search request.\nYou can then execute the search based on the request.\nExample: get all views in a schema\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\nval\nschemaQN\n=\n\"default/snowflake/1662194632/MYDB/MY_SCH\"\n// (1)\nval\nfindViews\n=\nclient\n.\nassets\n.\nselect\n()\n// (2)\n.\nwhere\n(\nAsset\n.\nQUALIFIED_NAME\n.\nstartsWith\n(\nschemaQN\n))\n// (3)\n.\nwhere\n(\nAsset\n.\nTYPE_NAME\n.\n`in`\n(\nlistOf\n(\nView\n.\nTYPE_NAME\n,\nMaterializedView\n.\nTYPE_NAME\n)))\n// (4)\n.\nwhereNot\n(\nAsset\n.\nCERTIFICATE_STATUS\n.\nhasAnyValue\n())\n// (5)\n.\npageSize\n(\n100\n)\n// (6)\n.\nincludeOnResults\n(\nAsset\n.\nDESCRIPTION\n)\n// (7)\n.\nincludeOnResults\n(\nAsset\n.\nCERTIFICATE_STATUS\n)\n.\nincludeOnResults\n(\nAsset\n.\nOWNER_USERS\n)\n.\ntoRequest\n()\n// (8)\nval\nresponse\n=\nfindViews\n.\nsearch\n()\n// (9)\nThe\nqualifiedName\nof every view starts with the\nqualifiedName\nof its parent (schema), so we can limit the results to a particular schema by using the\nqualifiedName\n.",
    "metadata": {
      "source_url": "patterns_bulk_end-to-end.html",
      "source_type": "sdk",
      "file": "patterns_bulk_end-to-end.json",
      "chunk_id": 6
    }
  },
  {
    "content": "=\nfindViews\n.\nsearch\n()\n// (9)\nThe\nqualifiedName\nof every view starts with the\nqualifiedName\nof its parent (schema), so we can limit the results to a particular schema by using the\nqualifiedName\n.\nTo start building up a query with multiple conditions, you can use the\nselect()\nhelper on any client's\nassets\nmember.\nYou can chain\nwhere()\nmethods to define all the conditions the search results must match. You can use the static constants within any given type to select a particular attribute (like\nQUALIFIED_NAME\nin this example), and then limit results to only those assets whose\nqualifiedName\nstarts with the\nqualifiedName\nof the schema (by using the\nstartsWith()\npredicate). In this example, that means only assets that are within this particular schema will be returned as results.\nSince there could be tables, views, materialized views and columns in this schema — but you only want views and materialized views — you can use the\nAsset.TYPE_NAME.in()\nhelper method to restrict results to only views and materialized views.\nSince you only want to update views that do not already have a certificate, you can further limit the results using the\nwhereNot()",
    "metadata": {
      "source_url": "patterns_bulk_end-to-end.html",
      "source_type": "sdk",
      "file": "patterns_bulk_end-to-end.json",
      "chunk_id": 7
    }
  },
  {
    "content": "Since you only want to update views that do not already have a certificate, you can further limit the results using the\nwhereNot()\nmethod. This will exclude any assets where a certificate already\nhasAnyValue()\n.\nHere you can play around with different page sizes, to further limit API calls by retrieving more results per page.\nAdd as many attributes as needed. Each attribute you add here will ensure that detail is included in each search result. So in this example, every view will include its description, certificate, and individual owners. (Limit these attributes to the minimum you need about each view to do your intended work.)\nYou can translate the object you've built up into various outputs, for example immediately calculating a count of how many results match or streaming them directly for processing. In this case, the\ntoRequest()\nmethod will give us the resulting set of criteria back as a complete index search request.\nYou can then execute the search based on the request.\nPOST /api/meta/search/indexsearch\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n{\n\"dsl\"",
    "metadata": {
      "source_url": "patterns_bulk_end-to-end.html",
      "source_type": "sdk",
      "file": "patterns_bulk_end-to-end.json",
      "chunk_id": 8
    }
  },
  {
    "content": "1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n{\n\"dsl\"\n:\n{\n// (1)\n\"query\"\n:\n{\n\"bool\"\n:\n{\n// (2)\n\"filter\"\n:\n[\n// (3)\n{\n\"prefix\"\n:\n{\n// (4)\n\"qualifiedName\"\n:\n{\n\"value\"\n:\n\"default/snowflake/1662194632/MYDB/MY_SCH\"\n}\n}\n},\n{\n\"terms\"\n:\n{\n// (5)\n\"__typeName.keyword\"\n:\n[\n\"View\"\n,\n\"MaterialisedView\"\n]\n}\n},\n{\n\"term\"\n:\n{\n// (6)\n\"__state\"\n:\n{\n\"value\"\n:\n\"ACTIVE\"\n}\n}\n}\n],\n\"must_not\"\n:\n[\n// (7)\n{\n\"exists\"\n:\n{\n\"field\"\n:\n\"certificateStatus\"\n}\n}\n]\n}\n},\n\"sort\"\n:\n[\n// (8)\n{\n\"__guid\"\n:\n{\n\"order\"\n:\n\"asc\"\n}\n}\n],\n\"from\"\n:\n0\n,\n// (9)\n\"size\"\n:\n100\n,\n\"track_total_hits\"\n:\ntrue\n},\n\"attributes\"\n:\n[\n// (10)\n\"description\"\n,\n\"certificateStatus\"\n,\n\"ownerUsers\"\n],\n\"suppressLogs\"\n:\ntrue\n,\n\"showSearchScore\"\n:\nfalse\n,\n\"excludeMeanings\"\n:\nfalse\n,\n\"excludeClassifications\"\n:\nfalse\n}\nRun a search to find the views and materialized views.\nTo start building up a query with multiple conditions, you can use a\nbool\nquery in Elasticsearch.\nYou can use the\nfilter",
    "metadata": {
      "source_url": "patterns_bulk_end-to-end.html",
      "source_type": "sdk",
      "file": "patterns_bulk_end-to-end.json",
      "chunk_id": 9
    }
  },
  {
    "content": ":\nfalse\n}\nRun a search to find the views and materialized views.\nTo start building up a query with multiple conditions, you can use a\nbool\nquery in Elasticsearch.\nYou can use the\nfilter\ncriteria to define all the conditions the search results must match in a binary way (either matches or doesn't). This avoids the need to calculate a score for each result.\nThe\nqualifiedName\nof every view starts with the\nqualifiedName\nof its parent (schema), so we can limit the results to a particular schema by using the\nqualifiedName\n.\nSince there could be tables, views, materialized views and columns in this schema — but you only want views and materialized views — you can use an exact match on multiple types to restrict results to only views and materialized views.\nSearches by default will return\nall\nassets that are found — whether active or archived (soft-deleted). In most cases, you probably only want the active ones.\nSince you only want to update views that do not already have a certificate, you can further limit the results using the\nmust_not\nclause. This will exclude any assets that already have a certificate present.",
    "metadata": {
      "source_url": "patterns_bulk_end-to-end.html",
      "source_type": "sdk",
      "file": "patterns_bulk_end-to-end.json",
      "chunk_id": 10
    }
  },
  {
    "content": "must_not\nclause. This will exclude any assets that already have a certificate present.\nWhen paging through results, you should specify a sort to give a stable set of results across pages. The most reliable sort will be by GUID of the asset, as this is guaranteed to be unique for every asset.\nHere you can play around with different page sizes, to further limit API calls by retrieving more results per page.\nAdd as many attributes as needed. Each attribute you add here will ensure that detail is included in each search result. So in this example, every view will include its description, certificate, and individual owners. (Limit these attributes to the minimum you need about each column to do your intended work.)\n2. Build-up your changes\n¶\n3.0.0\n1.10.5\nNext, you iterate through those results and make the changes you want to each one. Use the\nmultiple operations pattern\nto make multiple changes to each asset.\nJava\nPython\nKotlin\nRaw REST API\nExample: iterate through results and make changes\n13\n14\n15\n16\n17\n18\n19\n20\n21\nAssetBatch\nbatch\n=\nnew\nAssetBatch\n(\nclient\n,\n20\n);\n// (1)\ntry\n{\nfor\n(\nAsset\nresult\n:\nresponse\n)\n{\n// (2)\nAsset\nrevised\n=\nresult\n.\ntrimToRequired\n()\n// (3)\n.",
    "metadata": {
      "source_url": "patterns_bulk_end-to-end.html",
      "source_type": "sdk",
      "file": "patterns_bulk_end-to-end.json",
      "chunk_id": 11
    }
  },
  {
    "content": "13\n14\n15\n16\n17\n18\n19\n20\n21\nAssetBatch\nbatch\n=\nnew\nAssetBatch\n(\nclient\n,\n20\n);\n// (1)\ntry\n{\nfor\n(\nAsset\nresult\n:\nresponse\n)\n{\n// (2)\nAsset\nrevised\n=\nresult\n.\ntrimToRequired\n()\n// (3)\n.\ncertificateStatus\n(\nCertificateStatus\n.\nVERIFIED\n)\n// (4)\n.\nownerUser\n(\n\"jsmith\"\n)\n.\nbuild\n();\nbatch\n.\nadd\n(\nrevised\n);\n// (5)\n}\nCreate a batch of assets to build-up the changes across multiple assets before applying those changes in Atlan itself.\nThe first parameter defines the Atlan tenant on which the batch will be processed\nThe second specifies the maximum number of assets to build-up before sending them across to Atlan\nAdditional parameters\nBy default (using only the options above) no classifications or custom metadata will be added or changed on the assets in each batch. To also include classifications and custom metadata, you need to use these additional parameters:\nA third parameter of\ntrue\nto replace all classifications on the assets in the batch, which would include removing classifications if none are provided for the assets in the batch itself (or\nfalse\nif you still want to ignore classifications)\nA fourth parameter to control how custom metadata should be handled for the assets:\nIGNORE",
    "metadata": {
      "source_url": "patterns_bulk_end-to-end.html",
      "source_type": "sdk",
      "file": "patterns_bulk_end-to-end.json",
      "chunk_id": 12
    }
  },
  {
    "content": "false\nif you still want to ignore classifications)\nA fourth parameter to control how custom metadata should be handled for the assets:\nIGNORE\nany custom metadata changes in the batch,\nOVERWRITE\nto replace all custom metadata with what's provided in the batch (including removing custom metadata that already exists on an asset), or\nMERGE\nto only add or update custom metadata based on what's in the batch (leaving other existing custom metadata unchanged)\na fifth parameter to control whether failures should be captured across batches (\ntrue\n) or ignored (\nfalse\n)\na sixth parameter to control whether the batch should only attempt to update assets that already exist (\ntrue\n) or also create assets if they do not yet exist (\nfalse\n)\na seventh parameter to control whether details about each created and updated asset across batches should be tracked (\ntrue\n) or ignored (\nfalse\n) — counts will always be kept\nan eighth parameter to control whether the matching for determining whether an asset already exists should be done in a case-insensitive way (\ntrue\n) or case-sensitively (\nfalse\n)\na ninth parameter to control what kind of assets to create, if not running in\nupdateOnly",
    "metadata": {
      "source_url": "patterns_bulk_end-to-end.html",
      "source_type": "sdk",
      "file": "patterns_bulk_end-to-end.json",
      "chunk_id": 13
    }
  },
  {
    "content": "true\n) or case-sensitively (\nfalse\n)\na ninth parameter to control what kind of assets to create, if not running in\nupdateOnly\nmode: partial assets (only available in lineage), or full assets\na tenth parameter to control whether the matching for determining whether an asset already exists should be done strictly according to the data type specified (\nfalse\n), or if tables, views and materialized views should be treated interchangeably (\ntrue\n)\nThis is the pattern for iterating through all results (across pages) covered in the\nSearching for assets\nportion of the SDK documentation.\nEvery asset implements the\ntrimToRequired()\nmethod, which gives you a builder containing only the bare minimum information needed to update that asset.\nLimit your asset to only what you intend to update\nWhen you send an update to Atlan, it will only attempt to change the information you send in your request — leaving any information not in your request as-is (unchanged) on the asset in Atlan. By using\ntrimToRequired()\nyou can remove all information you do not want to update, and then chain on only the details you\ndo\nwant to update.",
    "metadata": {
      "source_url": "patterns_bulk_end-to-end.html",
      "source_type": "sdk",
      "file": "patterns_bulk_end-to-end.json",
      "chunk_id": 14
    }
  },
  {
    "content": "trimToRequired()\nyou can remove all information you do not want to update, and then chain on only the details you\ndo\nwant to update.\nIn this running example, you are updating the certificate to verified and setting a new owner — so you simply chain those updates onto the trimmed builder.\nYou can then add your (in-memory) modified asset to the batch.\nAuto-saves as it goes\nAs long as the number of assets built-up is below the maximum batch size specified when creating the batch, this will simply continue to build up the batch. As soon as you hit the size limit for the batch, though, this same method will call the\nsave()\noperation to batch-update all of those assets in a single API call.\nRemember to flush\nSince your loop could finish before you reach another full batch, you must always remember to\nflush()\nthe batch. This will send any remaining assets that were queued up, when the size of the queue did not yet reach the full batch size.\nExample: iterate through results and make changes\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\nbatch\n=\nBatch\n(\n# (1)\nclient\n=\nclient\n,\nmax_size\n=\n20\n,\nreplace_atlan_tags\n=\nFalse\n,\ncustom_metadata_handling\n=\nCustomMetadataHandling\n.\nIGNORE\n,",
    "metadata": {
      "source_url": "patterns_bulk_end-to-end.html",
      "source_type": "sdk",
      "file": "patterns_bulk_end-to-end.json",
      "chunk_id": 15
    }
  },
  {
    "content": "23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\nbatch\n=\nBatch\n(\n# (1)\nclient\n=\nclient\n,\nmax_size\n=\n20\n,\nreplace_atlan_tags\n=\nFalse\n,\ncustom_metadata_handling\n=\nCustomMetadataHandling\n.\nIGNORE\n,\ncapture_failures\n=\nFalse\n,\nupdate_only\n=\nFalse\n,\ntrack\n=\nFalse\n,\ncase_insensitive\n=\nFalse\n,\ntable_view_agnostic\n=\nFalse\n,\ncreation_handling\n=\nAssetCreationHandling\n.\nFULL\n,\n)\ntry\n:\nfor\nasset\nin\nresponse\n:\n# (2)\nrevised\n=\nasset\n.\ntrim_to_required\n()\n# (3)\nrevised\n.\ncertificate_status\n=\nCertificateStatus\n.\nVERIFIED\n# (4)\nrevised\n.\nowner_users\n=\n{\n\"jsmith\"\n}\nbatch\n.\nadd\n(\nasset\n)\n# (5)\nCreate a batch of assets to accumulate changes across multiple\nassets before applying those changes in Atlan itself. The\nBatch()\ntakes the following parameters:\nclient\n: an instance of\nAssetClient\n.\nmax_size\n: the maximum size of each batch to be processed (per API call).\nAdditional optional parameters\nBy default (using only the options above) no classifications or custom metadata will be added or changed on the assets in each batch. To also include classifications and custom metadata, you need to use these additional parameters:\nreplace_atlan_tags\n(\ndefault: False\n): If\nTrue",
    "metadata": {
      "source_url": "patterns_bulk_end-to-end.html",
      "source_type": "sdk",
      "file": "patterns_bulk_end-to-end.json",
      "chunk_id": 16
    }
  },
  {
    "content": "replace_atlan_tags\n(\ndefault: False\n): If\nTrue\nreplace all classifications (tags) on the assets in the batch, which would include removing classifications (tags) if none are provided for the assets in the batch itself (or\nFalse\nif you still want to ignore classifications)\ncustom_metadata_handling\n(\ndefault: CustomMetadataHandling.IGNORE\n): control how custom metadata should be handled for the assets:\nIGNORE\nany custom metadata changes in the batch,\nOVERWRITE\nto replace all custom metadata with what's provided in the batch (including removing custom metadata that already exists on an asset), or\nMERGE\nto only add or update custom metadata based on what's in the batch (leaving other existing custom metadata unchanged)\ncapture_failures\n(\ndefault: False\n): control whether failures should be captured across batches (\nTrue\n) or ignored (\nFalse\n)\nupdate_only\n(\ndefault: False\n): control whether the batch should only attempt to update assets that already exist (\nTrue\n) or also create assets if they do not yet exist (\nFalse\n)\ntrack\n(\ndefault: False\n): control whether details about each created and updated asset across batches should be tracked (\nTrue\n) or ignored (\nFalse",
    "metadata": {
      "source_url": "patterns_bulk_end-to-end.html",
      "source_type": "sdk",
      "file": "patterns_bulk_end-to-end.json",
      "chunk_id": 17
    }
  },
  {
    "content": "False\n)\ntrack\n(\ndefault: False\n): control whether details about each created and updated asset across batches should be tracked (\nTrue\n) or ignored (\nFalse\n) — counts will always be kept\ncase_insensitive\n(\ndefault: False\n): control whether the matching for determining whether an asset already exists should be done in a case-insensitive way (\nTrue\n) or case-sensitively (\nFalse\n)\ncreation_handling\n(\ndefault: AssetCreationHandling.FULL\n): control what kind of assets to create, if not running in\nupdate_only\nmode;\nPARTIAL\nassets (only available in lineage), or\nFULL\nassets\ntable_view_agnostic\n(\ndefault: False\n): control whether the matching for determining whether an asset already exists should be done strictly according to the data type specified (\nFalse\n), or if tables, views and materialized views should be treated interchangeably (\nTrue\n)\nThis is the pattern for iterating through all results (across pages) covered in the\nSearching for assets\nportion of the SDK documentation.\nEvery asset implements the\ntrim_to_required()\nmethod, which gives you an object containing only the bare minimum information needed to update that asset.\nLimit your asset to only what you intend to update",
    "metadata": {
      "source_url": "patterns_bulk_end-to-end.html",
      "source_type": "sdk",
      "file": "patterns_bulk_end-to-end.json",
      "chunk_id": 18
    }
  },
  {
    "content": "trim_to_required()\nmethod, which gives you an object containing only the bare minimum information needed to update that asset.\nLimit your asset to only what you intend to update\nWhen you send an update to Atlan, it will only attempt to change the information you send in your request — leaving any information not in your request as-is (unchanged) on the asset in Atlan. By using\ntrimToRequired()\nyou can remove all information you do not want to update, and then chain on only the details you\ndo\nwant to update.\nIn this running example, you are updating the certificate to verified and setting a new owner — so you simply add those updates onto the trimmed object.\nYou can then add your (in-memory) modified asset to the batch.\nAuto-saves as it goes\nAs long as the number of assets built-up is below the maximum batch size specified when creating the batch, this will simply continue to build up the batch. As soon as you hit the size limit for the batch, though, this same method will call the\nsave()\noperation to batch-update all of those assets in a single API call.\nRemember to flush\nSince your loop could finish before you reach another full batch, you must always remember to\nflush()",
    "metadata": {
      "source_url": "patterns_bulk_end-to-end.html",
      "source_type": "sdk",
      "file": "patterns_bulk_end-to-end.json",
      "chunk_id": 19
    }
  },
  {
    "content": "save()\noperation to batch-update all of those assets in a single API call.\nRemember to flush\nSince your loop could finish before you reach another full batch, you must always remember to\nflush()\nthe batch. This will send any remaining assets that were queued up, when the size of the queue did not yet reach the full batch size.\nExample: iterate through results and make changes\n13\n14\n15\n16\n17\n18\n19\n20\n21\nval\nbatch\n=\nAssetBatch\n(\nclient\n,\n20\n)\n// (1)\ntry\n{\nfor\n(\nresult\nin\nresponse\n)\n{\n// (2)\nval\nrevised\n=\nresult\n.\ntrimToRequired\n()\n// (3)\n.\ncertificateStatus\n(\nCertificateStatus\n.\nVERIFIED\n)\n// (4)\n.\nownerUser\n(\n\"jsmith\"\n)\n.\nbuild\n()\nbatch\n.\nadd\n(\nrevised\n)\n// (5)\n}\nCreate a batch of assets to build-up the changes across multiple assets before applying those changes in Atlan itself.\nThe first parameter defines the Atlan tenant on which the batch will be processed\nThe second specifies the maximum number of assets to build-up before sending them across to Atlan\nAdditional parameters",
    "metadata": {
      "source_url": "patterns_bulk_end-to-end.html",
      "source_type": "sdk",
      "file": "patterns_bulk_end-to-end.json",
      "chunk_id": 20
    }
  },
  {
    "content": "The second specifies the maximum number of assets to build-up before sending them across to Atlan\nAdditional parameters\nBy default (using only the options above) no classifications or custom metadata will be added or changed on the assets in each batch. To also include classifications and custom metadata, you need to use these additional parameters:\nA third parameter of\ntrue\nto replace all classifications on the assets in the batch, which would include removing classifications if none are provided for the assets in the batch itself (or\nfalse\nif you still want to ignore classifications)\nA fourth parameter to control how custom metadata should be handled for the assets:\nIGNORE\nany custom metadata changes in the batch,\nOVERWRITE\nto replace all custom metadata with what's provided in the batch (including removing custom metadata that already exists on an asset), or\nMERGE\nto only add or update custom metadata based on what's in the batch (leaving other existing custom metadata unchanged)\na fifth parameter to control whether failures should be captured across batches (\ntrue\n) or ignored (\nfalse\n)",
    "metadata": {
      "source_url": "patterns_bulk_end-to-end.html",
      "source_type": "sdk",
      "file": "patterns_bulk_end-to-end.json",
      "chunk_id": 21
    }
  },
  {
    "content": "a fifth parameter to control whether failures should be captured across batches (\ntrue\n) or ignored (\nfalse\n)\na sixth parameter to control whether the batch should only attempt to update assets that already exist (\ntrue\n) or also create assets if they do not yet exist (\nfalse\n)\na seventh parameter to control whether details about each created and updated asset across batches should be tracked (\ntrue\n) or ignored (\nfalse\n) — counts will always be kept\nan eighth parameter to control whether the matching for determining whether an asset already exists should be done in a case-insensitive way (\ntrue\n) or case-sensitively (\nfalse\n)\na ninth parameter to control what kind of assets to create, if not running in\nupdateOnly\nmode: partial assets (only available in lineage), or full assets\na tenth parameter to control whether the matching for determining whether an asset already exists should be done strictly according to the data type specified (\nfalse\n), or if tables, views and materialized views should be treated interchangeably (\ntrue\n)\nThis is the pattern for iterating through all results (across pages) covered in the\nSearching for assets\nportion of the SDK documentation.",
    "metadata": {
      "source_url": "patterns_bulk_end-to-end.html",
      "source_type": "sdk",
      "file": "patterns_bulk_end-to-end.json",
      "chunk_id": 22
    }
  },
  {
    "content": "true\n)\nThis is the pattern for iterating through all results (across pages) covered in the\nSearching for assets\nportion of the SDK documentation.\nEvery asset implements the\ntrimToRequired()\nmethod, which gives you a builder containing only the bare minimum information needed to update that asset.\nLimit your asset to only what you intend to update\nWhen you send an update to Atlan, it will only attempt to change the information you send in your request — leaving any information not in your request as-is (unchanged) on the asset in Atlan. By using\ntrimToRequired()\nyou can remove all information you do not want to update, and then chain on only the details you\ndo\nwant to update.\nIn this running example, you are updating the certificate to verified and setting a new owner — so you simply chain those updates onto the trimmed builder.\nYou can then add your (in-memory) modified asset to the batch.\nAuto-saves as it goes\nAs long as the number of assets built-up is below the maximum batch size specified when creating the batch, this will simply continue to build up the batch. As soon as you hit the size limit for the batch, though, this same method will call the\nsave()",
    "metadata": {
      "source_url": "patterns_bulk_end-to-end.html",
      "source_type": "sdk",
      "file": "patterns_bulk_end-to-end.json",
      "chunk_id": 23
    }
  },
  {
    "content": "save()\noperation to batch-update all of those assets in a single API call.\nRemember to flush\nSince your loop could finish before you reach another full batch, you must always remember to\nflush()\nthe batch. This will send any remaining assets that were queued up, when the size of the queue did not yet reach the full batch size.\nUp to your own code\nThere are no API calls to make to change the results in-memory. How you implement this will be entirely up to how you are writing your code.\n3. Save them in batches\n¶\n3.0.0\n1.1.0\nFinally, send the changes you have queued up in batches. Use the\nmultiple assets pattern\nto update multiple assets at the same time.\nJava\nPython\nKotlin\nRaw REST API\nExample: save the changes in batches\n22\n23\n24\n25\nbatch\n.\nflush\n();\n// (1)\n}\ncatch\n(\nAtlanException\ne\n)\n{\n// (2)\n}\nThe\nAssetBatch\n's\nadd()\nmethod used in the previous step will automatically save as its internal queue of assets reaches a full batch size.\nRemember to flush\nHowever, since your loop could finish before you reach another full batch, you must always remember to\nflush()\nthe batch. This will send any remaining assets that were queued up.\nBoth the\n.add()\nand\n.flush()\noperations of the",
    "metadata": {
      "source_url": "patterns_bulk_end-to-end.html",
      "source_type": "sdk",
      "file": "patterns_bulk_end-to-end.json",
      "chunk_id": 24
    }
  },
  {
    "content": "flush()\nthe batch. This will send any remaining assets that were queued up.\nBoth the\n.add()\nand\n.flush()\noperations of the\nAssetBatch\ncould send a request over to Atlan. Either can therefore also run into trouble and raise an error through an\nAtlanException\n. It is up to you to handle such potential errors as you see fit.\nExample: save the changes in batches\n30\n31\n32\nbatch\n.\nflush\n()\n# (1)\nexcept\nAtlanError\nas\nerr\n:\n...\n# (2)\nThe\nBatch\n's\nadd()\nmethod used in the previous step will automatically save as its internal queue of assets reaches a full batch size.\nRemember to flush\nHowever, since your loop could finish before you reach another full batch, you must always remember to\nflush()\nthe batch. This will send any remaining assets that were queued up.\nBoth the\n.add()\nand\n.flush()\noperations of the\nBatch\ncould send a request over to Atlan. Either can therefore also run into trouble and raise an error through an\nAtlanError\n. It is up to you to handle such potential errors as you see fit.\nExample: save the changes in batches\n22\n23\n24\n25\nbatch\n.\nflush\n()\n// (1)\n}\ncatch\n(\ne\n:\nAtlanException\n)\n{\n// (2)\n}\nThe\nAssetBatch\n's\nadd()",
    "metadata": {
      "source_url": "patterns_bulk_end-to-end.html",
      "source_type": "sdk",
      "file": "patterns_bulk_end-to-end.json",
      "chunk_id": 25
    }
  },
  {
    "content": "Example: save the changes in batches\n22\n23\n24\n25\nbatch\n.\nflush\n()\n// (1)\n}\ncatch\n(\ne\n:\nAtlanException\n)\n{\n// (2)\n}\nThe\nAssetBatch\n's\nadd()\nmethod used in the previous step will automatically save as its internal queue of assets reaches a full batch size.\nRemember to flush\nHowever, since your loop could finish before you reach another full batch, you must always remember to\nflush()\nthe batch. This will send any remaining assets that were queued up.\nBoth the\n.add()\nand\n.flush()\noperations of the\nAssetBatch\ncould send a request over to Atlan. Either can therefore also run into trouble and raise an error through an\nAtlanException\n. It is up to you to handle such potential errors as you see fit.\nPOST /api/meta/entity/bulk\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n{\n\"entities\"\n:\n[\n// (1)\n{\n\"typeName\"\n:\n\"View\"\n,\n// (2)\n\"attributes\"\n:\n{\n\"name\"\n:\n\"VIEW1\"\n,\n// (3)\n\"qualifiedName\"\n:\n\"default/snowflake/1662194632/MYDB/MY_SCH/VIEW1\"\n,\n\"certificateStatus\"\n:\n\"VERIFIED\"\n,\n// (4)\n\"ownerUsers\"\n:\n[\n\"jsmith\"\n]\n}\n},\n{\n// (5)\n\"typeName\"\n:\n\"MaterialisedView\"\n,\n\"attributes\"\n:\n{\n\"name\"\n:\n\"MVIEW2\"\n,\n\"qualifiedName\"\n:\n\"default/snowflake/1662194632/MYDB/MY_SCH/MVIEW2\"\n,\n\"certificateStatus\"\n:",
    "metadata": {
      "source_url": "patterns_bulk_end-to-end.html",
      "source_type": "sdk",
      "file": "patterns_bulk_end-to-end.json",
      "chunk_id": 26
    }
  },
  {
    "content": ":\n[\n\"jsmith\"\n]\n}\n},\n{\n// (5)\n\"typeName\"\n:\n\"MaterialisedView\"\n,\n\"attributes\"\n:\n{\n\"name\"\n:\n\"MVIEW2\"\n,\n\"qualifiedName\"\n:\n\"default/snowflake/1662194632/MYDB/MY_SCH/MVIEW2\"\n,\n\"certificateStatus\"\n:\n\"VERIFIED\"\n,\n\"ownerUsers\"\n:\n[\n\"jsmith\"\n]\n}\n}\n]\n}\nAll details must still be included in an outer\nentities\narray.\nYou need to specify the type for each asset you are updating.\nYou need to specify other required attributes for each asset, such as its name and qualifiedName.\nAdd on any other attributes or relationships you want to set on the asset, such as in the running example a verified certificate and new individual owner.\nAdd another object to the payload to represent another asset that should be updated by the same API call. Once again specify all the required information for that kind of asset, and any of the details for attributes or relationships you want to set.\nPipelining\n¶\n3.0.0\n1.10.5\nAlternatively, when using an SDK, you can pipeline these operations together. The pipeline will run just as efficiently as the step-by-step approach above:\nPushing down the criteria to run as a search on Atlan\nLazily-fetching each page of results\nBatching up and bulk-saving changes\nJava\nPython\nKotlin",
    "metadata": {
      "source_url": "patterns_bulk_end-to-end.html",
      "source_type": "sdk",
      "file": "patterns_bulk_end-to-end.json",
      "chunk_id": 27
    }
  },
  {
    "content": "Pushing down the criteria to run as a search on Atlan\nLazily-fetching each page of results\nBatching up and bulk-saving changes\nJava\nPython\nKotlin\nRaw REST API\nExample: pipelining\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\nString\nschemaQN\n=\n\"default/snowflake/1662194632/MYDB/MY_SCH\"\n;\n// (1)\ntry\n(\nParallelBatch\nbatch\n=\nnew\nParallelBatch\n(\nclient\n,\n20\n))\n{\n// (2)\nclient\n.\nassets\n.\nselect\n()\n// (3)\n.\nwhere\n(\nAsset\n.\nQUALIFIED_NAME\n.\nstartsWith\n(\nschemaQN\n))\n// (4)\n.\nwhere\n(\nAsset\n.\nTYPE_NAME\n.\nin\n(\nList\n.\nof\n(\nView\n.\nTYPE_NAME\n,\nMaterializedView\n.\nTYPE_NAME\n)))\n// (5)\n.\nwhereNot\n(\nAsset\n.\nCERTIFICATE_STATUS\n.\nhasAnyValue\n())\n// (6)\n.\npageSize\n(\n100\n)\n// (7)\n.\nincludeOnResults\n(\nAsset\n.\nDESCRIPTION\n)\n// (8)\n.\nincludeOnResults\n(\nAsset\n.\nCERTIFICATE_STATUS\n)\n.\nincludeOnResults\n(\nAsset\n.\nOWNER_USERS\n)\n.\nstream\n(\ntrue\n)\n// (9)\n.\nforEach\n(\nresult\n->\n{\n// (10)\ntry\n{\nbatch\n.\nadd\n(\nresult\n.\ntrimToRequired\n()\n// (11)\n.\ncertificateStatus\n(\nCertificateStatus\n.\nVERIFIED\n)\n// (12)\n.\nownerUser\n(\n\"jsmith\"\n)\n.\nbuild\n());\n// (13)\n}\ncatch\n(\nAtlanException\ne\n)\n{\n// (14)\nlog\n.\nerror\n(\n\"Unable to update: {}\"\n,\nresult\n.\ngetQualifiedName\n());\n}\n});\nbatch\n.\nflush\n();\n// (15)\nlog\n.\ninfo",
    "metadata": {
      "source_url": "patterns_bulk_end-to-end.html",
      "source_type": "sdk",
      "file": "patterns_bulk_end-to-end.json",
      "chunk_id": 28
    }
  },
  {
    "content": ".\nownerUser\n(\n\"jsmith\"\n)\n.\nbuild\n());\n// (13)\n}\ncatch\n(\nAtlanException\ne\n)\n{\n// (14)\nlog\n.\nerror\n(\n\"Unable to update: {}\"\n,\nresult\n.\ngetQualifiedName\n());\n}\n});\nbatch\n.\nflush\n();\n// (15)\nlog\n.\ninfo\n(\n\"Created: {}\"\n,\nbatch\n.\ngetCreated\n().\nsize\n());\nlog\n.\ninfo\n(\n\"Updated: {}\"\n,\nbatch\n.\ngetUpdated\n().\nsize\n());\n}\nThe\nqualifiedName\nof every view starts with the\nqualifiedName\nof its parent (schema), so we can limit the results to a particular schema by using the\nqualifiedName\n.\nCreate a batch of assets to build-up the changes across multiple assets before applying those changes in Atlan itself. When parallel-processing (see further notes on the\nstream(true)\n) you need to use a parallel-capable\nParallelBatch\n:\nThe first parameter defines the Atlan tenant on which the batch will be processed\nThe second specifies the maximum number of assets to build-up before sending them across to Atlan\nAdditional parameters\nBy default (using only the options above) no classifications or custom metadata will be added or changed on the assets in each batch. To also include classifications and custom metadata, you need to use these additional parameters:\nA third parameter of\ntrue",
    "metadata": {
      "source_url": "patterns_bulk_end-to-end.html",
      "source_type": "sdk",
      "file": "patterns_bulk_end-to-end.json",
      "chunk_id": 29
    }
  },
  {
    "content": "A third parameter of\ntrue\nto replace all classifications on the assets in the batch, which would include removing classifications if none are provided for the assets in the batch itself (or\nfalse\nif you still want to ignore classifications)\nA fourth parameter to control how custom metadata should be handled for the assets:\nIGNORE\nany custom metadata changes in the batch,\nOVERWRITE\nto replace all custom metadata with what's provided in the batch (including removing custom metadata that already exists on an asset), or\nMERGE\nto only add or update custom metadata based on what's in the batch (leaving other existing custom metadata unchanged)\na fifth parameter to control whether failures should be captured across batches (\ntrue\n) or ignored (\nfalse\n)\na sixth parameter to control whether the batch should only attempt to update assets that already exist (\ntrue\n) or also create assets if they do not yet exist (\nfalse\n)\na seventh parameter to control whether details about each created and updated asset across batches should be tracked (\ntrue\n) or ignored (\nfalse\n) — counts will always be kept",
    "metadata": {
      "source_url": "patterns_bulk_end-to-end.html",
      "source_type": "sdk",
      "file": "patterns_bulk_end-to-end.json",
      "chunk_id": 30
    }
  },
  {
    "content": "false\n)\na seventh parameter to control whether details about each created and updated asset across batches should be tracked (\ntrue\n) or ignored (\nfalse\n) — counts will always be kept\nan eighth parameter to control whether the matching for determining whether an asset already exists should be done in a case-insensitive way (\ntrue\n) or case-sensitively (\nfalse\n)\na ninth parameter to control what kind of assets to create, if not running in\nupdateOnly\nmode: partial assets (only available in lineage), or full assets\na tenth parameter to control whether the matching for determining whether an asset already exists should be done strictly according to the data type specified (\nfalse\n), or if tables, views and materialized views should be treated interchangeably (\ntrue\n)\nYou can then start defining a pipeline directly against the client's\nassets\nby using the\nselect()\nmethod.\nIncluding archived (soft-deleted) assets\nSearches by default will return\nall\nassets that are found — whether active or archived (soft-deleted). In most cases, you probably only want the active ones, so this is the default behavior of\nselect()\n. Sending in\ntrue\nto this\nselect()\nmethod will start the pipeline to\ninclude",
    "metadata": {
      "source_url": "patterns_bulk_end-to-end.html",
      "source_type": "sdk",
      "file": "patterns_bulk_end-to-end.json",
      "chunk_id": 31
    }
  },
  {
    "content": "select()\n. Sending in\ntrue\nto this\nselect()\nmethod will start the pipeline to\ninclude\nany archived (soft-deleted) assets in the results, if you do want them.\nYou can chain as many\nwhere()\nmethods as you want to define all the conditions the search results must match. You can use the static constants within any given type to select a particular attribute (like\nQUALIFIED_NAME\nin this example), and then limit results to only those assets whose\nqualifiedName\nstarts with the\nqualifiedName\nof the schema (by using the\nstartsWith()\npredicate). In this example, that means only assets that are within this particular schema will be returned as results.\nSince there could be tables, views, materialized views and columns in this schema — but you only want views and materialized views — you can use the\nAsset.TYPE_NAME.in()\nmethod to restrict results to only views and materialized views.\nSince you only want to update views that do not already have a certificate, you can further limit the results using the\nwhereNot()\nmethod. This will exclude any assets where a certificate already\nhasAnyValue()\n.",
    "metadata": {
      "source_url": "patterns_bulk_end-to-end.html",
      "source_type": "sdk",
      "file": "patterns_bulk_end-to-end.json",
      "chunk_id": 32
    }
  },
  {
    "content": "whereNot()\nmethod. This will exclude any assets where a certificate already\nhasAnyValue()\n.\n(Optional) You can play around with different page sizes, to further limit API calls by retrieving more results per page.\nAdd as many attributes as needed. Each attribute you add here will ensure that detail is included in each search result. So in this example, every view will include its description, certificate, and individual owners. (Limit these attributes to the minimum you need about each view to do your intended work.)\nOnce you have defined the criteria for your pipeline, call the\nstream()\nmethod to push-down the pipeline to Atlan. This will:\nCreate a search that combines all the criteria you have specified.\nRun that search against Atlan to produce the first page of results.\nPage through the results by lazily fetching each subsequent page as you iterate through them. (So if you use a\nlimit()\non the stream, for example, you can break out before retrieving all pages.)\nCan also run in parallel threads\nYou can also parallel-stream the results by passing\ntrue\nto the\nstream()",
    "metadata": {
      "source_url": "patterns_bulk_end-to-end.html",
      "source_type": "sdk",
      "file": "patterns_bulk_end-to-end.json",
      "chunk_id": 33
    }
  },
  {
    "content": "limit()\non the stream, for example, you can break out before retrieving all pages.)\nCan also run in parallel threads\nYou can also parallel-stream the results by passing\ntrue\nto the\nstream()\nmethod. This will spawn multiple threads that each independently process a page of results and combine the results in parallel. While this can be significantly faster for processing many results, keep in mind if you are collecting the results into any structure that structure must be thread-safe. (For example, you'll need to use things like\nConcurrentHashMap\nrather than just\nHashMap\n, and to use\nParallelBatch\nrather than\nAssetBatch\nif making changes.)\nFor each result, you can then carry out your changes and submit them into the batch.\nEvery asset implements the\ntrimToRequired()\nmethod, which gives you a builder containing only the bare minimum information needed to update that asset.\nLimit your asset to only what you intend to update\nWhen you send an update to Atlan, it will only attempt to change the information you send in your request — leaving any information not in your request as-is (unchanged) on the asset in Atlan. By using\ntrimToRequired()",
    "metadata": {
      "source_url": "patterns_bulk_end-to-end.html",
      "source_type": "sdk",
      "file": "patterns_bulk_end-to-end.json",
      "chunk_id": 34
    }
  },
  {
    "content": "trimToRequired()\nyou can remove all information you do not want to update, and then chain on only the details you\ndo\nwant to update.\nIn this running example, you are updating the certificate to verified and setting a new owner — so you simply chain those updates onto the trimmed builder.\nYou can then add your (in-memory) modified asset to the batch.\nAuto-saves as it goes\nAs long as the number of assets built-up is below the maximum batch size specified when creating the batch, this will simply continue to build up the batch. As soon as you hit the size limit for the batch, though, this same method will call the\nsave()\noperation to batch-update all of those assets in a single API call.\nRemember to flush\nSince your loop could finish before you reach another full batch, you must always remember to\nflush()\nthe batch. This will send any remaining assets that were queued up, when the size of the queue did not yet reach the full batch size.\nBoth the\n.add()\nand\n.flush()\noperations of the\nAssetBatch\ncould send a request over to Atlan. Either can therefore also run into trouble and raise an error through an\nAtlanException\n. It is up to you to handle such potential errors as you see fit.\nThe",
    "metadata": {
      "source_url": "patterns_bulk_end-to-end.html",
      "source_type": "sdk",
      "file": "patterns_bulk_end-to-end.json",
      "chunk_id": 35
    }
  },
  {
    "content": "could send a request over to Atlan. Either can therefore also run into trouble and raise an error through an\nAtlanException\n. It is up to you to handle such potential errors as you see fit.\nThe\nAssetBatch\n's\nadd()\nmethod used in the previous step will automatically save as its internal queue of assets reaches a full batch size.\nRemember to flush\nHowever, since your loop could finish before you reach another full batch, you must always remember to\nflush()\nthe batch. This will send any remaining assets that were queued up.\nExample: pipelining\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\nimport\nlogging\nfrom\npyatlan.client.atlan\nimport\nAtlanClient\nfrom\npyatlan.client.asset\nimport\nBatch\nfrom\npyatlan.model.enums\nimport\nCertificateStatus\nfrom\npyatlan.model.fluent_search\nimport\nCompoundQuery\n,\nFluentSearch\nfrom\npyatlan.model.assets\nimport\nAsset\n,\nView\n,\nMaterialisedView\nLOGGER\n=\nlogging\n.\ngetLogger\n(\n__name__\n)\nclient\n=\nAtlanClient\n()\nschema_qualified_name\n=\n\"default/snowflake/1662194632/MYDB/MY_SCH\"\n# (1)\nbatch\n=\nBatch\n(\n# (2)\nclient\n=\nclient\n,\nmax_size\n=\n20\n,\nreplace_atlan_tags\n=\nFalse\n,",
    "metadata": {
      "source_url": "patterns_bulk_end-to-end.html",
      "source_type": "sdk",
      "file": "patterns_bulk_end-to-end.json",
      "chunk_id": 36
    }
  },
  {
    "content": "(\n__name__\n)\nclient\n=\nAtlanClient\n()\nschema_qualified_name\n=\n\"default/snowflake/1662194632/MYDB/MY_SCH\"\n# (1)\nbatch\n=\nBatch\n(\n# (2)\nclient\n=\nclient\n,\nmax_size\n=\n20\n,\nreplace_atlan_tags\n=\nFalse\n,\ncustom_metadata_handling\n=\nCustomMetadataHandling\n.\nIGNORE\n,\ncapture_failures\n=\nFalse\n,\nupdate_only\n=\nFalse\n,\ntrack\n=\nFalse\n,\ncase_insensitive\n=\nFalse\n,\ntable_view_agnostic\n=\nFalse\n,\ncreation_handling\n=\nAssetCreationHandling\n.\nFULL\n,\n)\nfind_views\n=\n(\nFluentSearch\n()\n# (3)\n.\nwhere\n(\nAsset\n.\nQUALIFIED_NAME\n.\nstartswith\n(\nschema_qualified_name\n))\n# (4)\n.\nwhere\n(\nCompoundQuery\n.\nasset_types\n([\nView\n,\nMaterialisedView\n]))\n# (5)\n.\nwhere\n(\nCompoundQuery\n.\nactive_assets\n())\n.\nwhere_not\n(\nAsset\n.\nCERTIFICATE_STATUS\n.\nhas_any_value\n())\n# (6)\n.\npage_size\n(\n100\n)\n# (7)\n.\ninclude_on_results\n(\nAsset\n.\nDESCRIPTION\n)\n# (8)\n.\ninclude_on_results\n(\nAsset\n.\nCERTIFICATE_STATUS\n)\n.\ninclude_on_results\n(\nAsset\n.\nOWNER_USERS\n)\n)\n.\nto_request\n()\n# (9)\nresponse\n=\nclient\n.\nasset\n.\nsearch\n(\nfind_views\n)\n# (10)\ntry\n:\nfor\nasset\nin\nresponse\n:\n# (11)\nrevised\n=\nasset\n.\ntrim_to_required\n()\n# (12)\nrevised\n.\ncertificate_status\n=\nCertificateStatus\n.\nVERIFIED\n# (13)\nrevised\n.\nowner_users\n=\n{\n\"jsmith\"\n}\nbatch\n.\nadd\n(\nasset\n)",
    "metadata": {
      "source_url": "patterns_bulk_end-to-end.html",
      "source_type": "sdk",
      "file": "patterns_bulk_end-to-end.json",
      "chunk_id": 37
    }
  },
  {
    "content": "asset\nin\nresponse\n:\n# (11)\nrevised\n=\nasset\n.\ntrim_to_required\n()\n# (12)\nrevised\n.\ncertificate_status\n=\nCertificateStatus\n.\nVERIFIED\n# (13)\nrevised\n.\nowner_users\n=\n{\n\"jsmith\"\n}\nbatch\n.\nadd\n(\nasset\n)\n# (14)\nbatch\n.\nflush\n()\n# (15)\nLOGGER\n.\ninfo\n(\n\"Created\n%s\n\"\n,\nlen\n(\nbatch\n.\ncreated\n))\nLOGGER\n.\ninfo\n(\n\"Updated\n%s\n\"\n,\nlen\n(\nbatch\n.\nupdated\n))\nexcept\nAtlanError\nas\nerr\n:\nLOGGER\n.\nerror\n(\n\"Unable to update:\n%s\n\"\n,\nasset\n.\nqualified_name\n)\nThe\nqualifiedName\nof every view starts with the\nqualifiedName\nof its parent (schema), so we can limit the results to a particular schema by using the\nqualifiedName\n.\nCreate a batch of assets to accumulate changes across multiple\nassets before applying those changes in Atlan itself. The\nBatch()\ntakes the following parameters:\nclient\n: an instance of\nAssetClient\n.\nmax_size\n: the maximum size of each batch to be processed (per API call).\nAdditional optional parameters\nBy default (using only the options above) no classifications or custom metadata will be added or changed on the assets in each batch. To also include classifications and custom metadata, you need to use these additional parameters:\nreplace_atlan_tags\n(\ndefault: False\n): If\nTrue",
    "metadata": {
      "source_url": "patterns_bulk_end-to-end.html",
      "source_type": "sdk",
      "file": "patterns_bulk_end-to-end.json",
      "chunk_id": 38
    }
  },
  {
    "content": "replace_atlan_tags\n(\ndefault: False\n): If\nTrue\nreplace all classifications (tags) on the assets in the batch, which would include removing classifications (tags) if none are provided for the assets in the batch itself (or\nFalse\nif you still want to ignore classifications)\ncustom_metadata_handling\n(\ndefault: CustomMetadataHandling.IGNORE\n): control how custom metadata should be handled for the assets:\nIGNORE\nany custom metadata changes in the batch,\nOVERWRITE\nto replace all custom metadata with what's provided in the batch (including removing custom metadata that already exists on an asset), or\nMERGE\nto only add or update custom metadata based on what's in the batch (leaving other existing custom metadata unchanged)\ncapture_failures\n(\ndefault: False\n): control whether failures should be captured across batches (\nTrue\n) or ignored (\nFalse\n)\nupdate_only\n(\ndefault: False\n): control whether the batch should only attempt to update assets that already exist (\nTrue\n) or also create assets if they do not yet exist (\nFalse\n)\ntrack\n(\ndefault: False\n): control whether details about each created and updated asset across batches should be tracked (\nTrue\n) or ignored (\nFalse",
    "metadata": {
      "source_url": "patterns_bulk_end-to-end.html",
      "source_type": "sdk",
      "file": "patterns_bulk_end-to-end.json",
      "chunk_id": 39
    }
  },
  {
    "content": "False\n)\ntrack\n(\ndefault: False\n): control whether details about each created and updated asset across batches should be tracked (\nTrue\n) or ignored (\nFalse\n) — counts will always be kept\ncase_insensitive\n(\ndefault: False\n): control whether the matching for determining whether an asset already exists should be done in a case-insensitive way (\nTrue\n) or case-sensitively (\nFalse\n)\ncreation_handling\n(\ndefault: AssetCreationHandling.FULL\n): control what kind of assets to create, if not running in\nupdate_only\nmode;\nPARTIAL\nassets (only available in lineage), or\nFULL\nassets\ntable_view_agnostic\n(\ndefault: False\n): control whether the matching for determining whether an asset already exists should be done strictly according to the data type specified (\nFalse\n), or if tables, views and materialized views should be treated interchangeably (\nTrue\n)\nYou can then start defining a pipeline directly using a\nFluentSearch()\nobject.\nYou can chain as many\nwhere()\nmethods as you want to define all the conditions the search results must match. You can use the class variables within any given type to select a particular attribute (like\nQUALIFIED_NAME",
    "metadata": {
      "source_url": "patterns_bulk_end-to-end.html",
      "source_type": "sdk",
      "file": "patterns_bulk_end-to-end.json",
      "chunk_id": 40
    }
  },
  {
    "content": "where()\nmethods as you want to define all the conditions the search results must match. You can use the class variables within any given type to select a particular attribute (like\nQUALIFIED_NAME\nin this example), and then limit results to only those assets whose\nqualified_name\nstarts with the\nqualified_name\nof the schema (by using the\nstartswith()\npredicate). In this example, that means only assets that are within this particular schema will be returned as results.\nSince there could be tables, views, materialized views and columns in this schema — but you only want views and materialized views — you can use the\nCompoundQuery.asset_types()\nhelper method to restrict results to only views and materialized views.\nSince you only want to update views that do not already have a certificate, you can further limit the results using the\nwhere_not()\nmethod. This will exclude any assets where a certificate already\nhas_any_value()\n.\n(Optional) You can play around with different page sizes, to further limit API calls by retrieving more results per page.",
    "metadata": {
      "source_url": "patterns_bulk_end-to-end.html",
      "source_type": "sdk",
      "file": "patterns_bulk_end-to-end.json",
      "chunk_id": 41
    }
  },
  {
    "content": "has_any_value()\n.\n(Optional) You can play around with different page sizes, to further limit API calls by retrieving more results per page.\nAdd as many attributes as needed. Each attribute you add here will ensure that detail is included in each search result. So in this example, every view will include its description, certificate, and individual owners. (Limit these attributes to the minimum you need about each view to do your intended work.)\nYou can translate the object you've built up into various outputs, for example immediately calculating a count of how many results match or streaming them directly for processing. In this case, the\ntoRequest()\nmethod will give us the resulting set of criteria back as a complete index search request.\nYou can then execute the search based on the request.tore all of those details back into a response object.\nFor each result, you can then carry out your changes and submit them into the batch.\nEvery asset implements the\ntrim_to_required()\nmethod, which gives you a builder containing only the bare minimum information needed to update that asset.\nLimit your asset to only what you intend to update",
    "metadata": {
      "source_url": "patterns_bulk_end-to-end.html",
      "source_type": "sdk",
      "file": "patterns_bulk_end-to-end.json",
      "chunk_id": 42
    }
  },
  {
    "content": "trim_to_required()\nmethod, which gives you a builder containing only the bare minimum information needed to update that asset.\nLimit your asset to only what you intend to update\nWhen you send an update to Atlan, it will only attempt to change the information you send in your request — leaving any information not in your request as-is (unchanged) on the asset in Atlan. By using\ntrim_to_required()\nyou can remove all information you do not want to update, and then chain on only the details you\ndo\nwant to update.\nIn this running example, you are updating the certificate to verified and setting a new owner — so you simply set those updates on the trimmed object.\nYou can then add your (in-memory) modified asset to the batch.\nThe\nBatch\n's\nadd()\nmethod used in the previous step will automatically save as its internal queue of assets reaches a full batch size.\nRemember to flush\nHowever, since your loop could finish before you reach another full batch, you must always remember to\nflush()\nthe batch. This will send any remaining assets that were queued up.\nExample: pipelining\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\nval\nschemaQN\n=",
    "metadata": {
      "source_url": "patterns_bulk_end-to-end.html",
      "source_type": "sdk",
      "file": "patterns_bulk_end-to-end.json",
      "chunk_id": 43
    }
  },
  {
    "content": "flush()\nthe batch. This will send any remaining assets that were queued up.\nExample: pipelining\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\nval\nschemaQN\n=\n\"default/snowflake/1662194632/MYDB/MY_SCH\"\n// (1)\nParallelBatch\n(\nclient\n,\n20\n).\nuse\n{\nbatch\n->\n// (2)\nclient\n.\nassets\n.\nselect\n()\n// (3)\n.\nwhere\n(\nAsset\n.\nQUALIFIED_NAME\n.\nstartsWith\n(\nschemaQN\n))\n// (4)\n.\nwhere\n(\nAsset\n.\nTYPE_NAME\n.\n`in`\n(\nlistOf\n(\nView\n.\nTYPE_NAME\n,\nMaterializedView\n.\nTYPE_NAME\n)))\n// (5)\n.\nwhereNot\n(\nAsset\n.\nCERTIFICATE_STATUS\n.\nhasAnyValue\n())\n// (6)\n.\npageSize\n(\n100\n)\n// (7)\n.\nincludeOnResults\n(\nAsset\n.\nDESCRIPTION\n)\n// (8)\n.\nincludeOnResults\n(\nAsset\n.\nCERTIFICATE_STATUS\n)\n.\nincludeOnResults\n(\nAsset\n.\nOWNER_USERS\n)\n.\nstream\n(\ntrue\n)\n// (9)\n.\nforEach\n(\nresult\n->\n{\n// (10)\ntry\n{\nbatch\n.\nadd\n(\nresult\n.\ntrimToRequired\n()\n// (11)\n.\ncertificateStatus\n(\nCertificateStatus\n.\nVERIFIED\n)\n// (12)\n.\nownerUser\n(\n\"jsmith\"\n)\n.\nbuild\n())\n// (13)\n}\ncatch\n(\nAtlanException\ne\n)\n{\n// (14)\nlog\n.\nerror\n(\n\"Unable to update: {}\"\n,\nresult\n.\nqualifiedName\n);\n}\n});\nbatch\n.\nflush\n()\n// (15)\nlog\n.\ninfo\n(\n\"Created: {}\"\n,\nbatch\n.\ncreated\n.\nsize\n)\nlog\n.\ninfo\n(\n\"Updated: {}\"\n,\nbatch\n.\nupdated\n.\nsize\n)\n}\nThe",
    "metadata": {
      "source_url": "patterns_bulk_end-to-end.html",
      "source_type": "sdk",
      "file": "patterns_bulk_end-to-end.json",
      "chunk_id": 44
    }
  },
  {
    "content": "(\n\"Unable to update: {}\"\n,\nresult\n.\nqualifiedName\n);\n}\n});\nbatch\n.\nflush\n()\n// (15)\nlog\n.\ninfo\n(\n\"Created: {}\"\n,\nbatch\n.\ncreated\n.\nsize\n)\nlog\n.\ninfo\n(\n\"Updated: {}\"\n,\nbatch\n.\nupdated\n.\nsize\n)\n}\nThe\nqualifiedName\nof every view starts with the\nqualifiedName\nof its parent (schema), so we can limit the results to a particular schema by using the\nqualifiedName\n.\nCreate a batch of assets to build-up the changes across multiple assets before applying those changes in Atlan itself. When parallel-processing (see further notes on the\nstream(true)\n) you need to use a parallel-capable\nParallelBatch\n:\nThe first parameter defines the Atlan tenant on which the batch will be processed\nThe second specifies the maximum number of assets to build-up before sending them across to Atlan\nAdditional parameters\nBy default (using only the options above) no classifications or custom metadata will be added or changed on the assets in each batch. To also include classifications and custom metadata, you need to use these additional parameters:\nA third parameter of\ntrue",
    "metadata": {
      "source_url": "patterns_bulk_end-to-end.html",
      "source_type": "sdk",
      "file": "patterns_bulk_end-to-end.json",
      "chunk_id": 45
    }
  },
  {
    "content": "A third parameter of\ntrue\nto replace all classifications on the assets in the batch, which would include removing classifications if none are provided for the assets in the batch itself (or\nfalse\nif you still want to ignore classifications)\nA fourth parameter to control how custom metadata should be handled for the assets:\nIGNORE\nany custom metadata changes in the batch,\nOVERWRITE\nto replace all custom metadata with what's provided in the batch (including removing custom metadata that already exists on an asset), or\nMERGE\nto only add or update custom metadata based on what's in the batch (leaving other existing custom metadata unchanged)\na fifth parameter to control whether failures should be captured across batches (\ntrue\n) or ignored (\nfalse\n)\na sixth parameter to control whether the batch should only attempt to update assets that already exist (\ntrue\n) or also create assets if they do not yet exist (\nfalse\n)\na seventh parameter to control whether details about each created and updated asset across batches should be tracked (\ntrue\n) or ignored (\nfalse\n) — counts will always be kept",
    "metadata": {
      "source_url": "patterns_bulk_end-to-end.html",
      "source_type": "sdk",
      "file": "patterns_bulk_end-to-end.json",
      "chunk_id": 46
    }
  },
  {
    "content": "false\n)\na seventh parameter to control whether details about each created and updated asset across batches should be tracked (\ntrue\n) or ignored (\nfalse\n) — counts will always be kept\nan eighth parameter to control whether the matching for determining whether an asset already exists should be done in a case-insensitive way (\ntrue\n) or case-sensitively (\nfalse\n)\na ninth parameter to control what kind of assets to create, if not running in\nupdateOnly\nmode: partial assets (only available in lineage), or full assets\na tenth parameter to control whether the matching for determining whether an asset already exists should be done strictly according to the data type specified (\nfalse\n), or if tables, views and materialized views should be treated interchangeably (\ntrue\n)\nYou can then start defining a pipeline directly against the client's\nassets\nby using the\nselect()\nmethod.\nIncluding archived (soft-deleted) assets\nSearches by default will return\nall\nassets that are found — whether active or archived (soft-deleted). In most cases, you probably only want the active ones, so this is the default behavior of\nselect()\n. Sending in\ntrue\nto this\nselect()\nmethod will start the pipeline to\ninclude",
    "metadata": {
      "source_url": "patterns_bulk_end-to-end.html",
      "source_type": "sdk",
      "file": "patterns_bulk_end-to-end.json",
      "chunk_id": 47
    }
  },
  {
    "content": "select()\n. Sending in\ntrue\nto this\nselect()\nmethod will start the pipeline to\ninclude\nany archived (soft-deleted) assets in the results, if you do want them.\nYou can chain as many\nwhere()\nmethods as you want to define all the conditions the search results must match. You can use the static constants within any given type to select a particular attribute (like\nQUALIFIED_NAME\nin this example), and then limit results to only those assets whose\nqualifiedName\nstarts with the\nqualifiedName\nof the schema (by using the\nstartsWith()\npredicate). In this example, that means only assets that are within this particular schema will be returned as results.\nSince there could be tables, views, materialized views and columns in this schema — but you only want views and materialized views — you can use the\nAsset.TYPE_NAME.in\nhelper method to restrict results to only views and materialized views.\nSince you only want to update views that do not already have a certificate, you can further limit the results using the\nwhereNot()\nmethod. This will exclude any assets where a certificate already\nhasAnyValue()\n.",
    "metadata": {
      "source_url": "patterns_bulk_end-to-end.html",
      "source_type": "sdk",
      "file": "patterns_bulk_end-to-end.json",
      "chunk_id": 48
    }
  },
  {
    "content": "whereNot()\nmethod. This will exclude any assets where a certificate already\nhasAnyValue()\n.\n(Optional) You can play around with different page sizes, to further limit API calls by retrieving more results per page.\nAdd as many attributes as needed. Each attribute you add here will ensure that detail is included in each search result. So in this example, every view will include its description, certificate, and individual owners. (Limit these attributes to the minimum you need about each view to do your intended work.)\nOnce you have defined the criteria for your pipeline, call the\nstream()\nmethod to push-down the pipeline to Atlan. This will:\nCreate a search that combines all the criteria you have specified.\nRun that search against Atlan to produce the first page of results.\nPage through the results by lazily fetching each subsequent page as you iterate through them. (So if you use a\nlimit()\non the stream, for example, you can break out before retrieving all pages.)\nCan also run in parallel threads\nYou can also parallel-stream the results by passing\ntrue\nto the\nstream()",
    "metadata": {
      "source_url": "patterns_bulk_end-to-end.html",
      "source_type": "sdk",
      "file": "patterns_bulk_end-to-end.json",
      "chunk_id": 49
    }
  },
  {
    "content": "limit()\non the stream, for example, you can break out before retrieving all pages.)\nCan also run in parallel threads\nYou can also parallel-stream the results by passing\ntrue\nto the\nstream()\nmethod. This will spawn multiple threads that each independently process a page of results and combine the results in parallel. While this can be significantly faster for processing many results, keep in mind if you are collecting the results into any structure that structure must be thread-safe. (For example, you'll need to use things like\nConcurrentHashMap\nrather than just\nHashMap\n, and to use\nParallelBatch\nrather than\nAssetBatch\nif making changes.)\nFor each result, you can then carry out your changes and submit them into the batch.\nEvery asset implements the\ntrimToRequired()\nmethod, which gives you a builder containing only the bare minimum information needed to update that asset.\nLimit your asset to only what you intend to update\nWhen you send an update to Atlan, it will only attempt to change the information you send in your request — leaving any information not in your request as-is (unchanged) on the asset in Atlan. By using\ntrimToRequired()",
    "metadata": {
      "source_url": "patterns_bulk_end-to-end.html",
      "source_type": "sdk",
      "file": "patterns_bulk_end-to-end.json",
      "chunk_id": 50
    }
  },
  {
    "content": "trimToRequired()\nyou can remove all information you do not want to update, and then chain on only the details you\ndo\nwant to update.\nIn this running example, you are updating the certificate to verified and setting a new owner — so you simply chain those updates onto the trimmed builder.\nYou can then add your (in-memory) modified asset to the batch.\nAuto-saves as it goes\nAs long as the number of assets built-up is below the maximum batch size specified when creating the batch, this will simply continue to build up the batch. As soon as you hit the size limit for the batch, though, this same method will call the\nsave()\noperation to batch-update all of those assets in a single API call.\nRemember to flush\nSince your loop could finish before you reach another full batch, you must always remember to\nflush()\nthe batch. This will send any remaining assets that were queued up, when the size of the queue did not yet reach the full batch size.\nBoth the\n.add()\nand\n.flush()\noperations of the\nAssetBatch\ncould send a request over to Atlan. Either can therefore also run into trouble and raise an error through an\nAtlanException\n. It is up to you to handle such potential errors as you see fit.\nThe",
    "metadata": {
      "source_url": "patterns_bulk_end-to-end.html",
      "source_type": "sdk",
      "file": "patterns_bulk_end-to-end.json",
      "chunk_id": 51
    }
  },
  {
    "content": "could send a request over to Atlan. Either can therefore also run into trouble and raise an error through an\nAtlanException\n. It is up to you to handle such potential errors as you see fit.\nThe\nAssetBatch\n's\nadd()\nmethod used in the previous step will automatically save as its internal queue of assets reaches a full batch size.\nRemember to flush\nHowever, since your loop could finish before you reach another full batch, you must always remember to\nflush()\nthe batch. This will send any remaining assets that were queued up.\nRequires numerous API calls\nTo implement the same logic purely through raw API calls will require making many calls:\nTo run the search.\nTo page through the results.\nTo batch up a set of assets to update.\nTo submit each batch of assets to update.\n2023-04-12\n2024-12-13\nWas this page helpful?\nThanks for your feedback!\nThanks for your feedback! Help us improve this page by using our\nfeedback form\nto provide us with more information.\nBack to top\nCookie consent\nWe use cookies to:\nAnonymously measure page views, and\nAllow you to give us one-click feedback on any page.\nWe do\nnot\ncollect or store:\nAny personally identifiable information.",
    "metadata": {
      "source_url": "patterns_bulk_end-to-end.html",
      "source_type": "sdk",
      "file": "patterns_bulk_end-to-end.json",
      "chunk_id": 52
    }
  },
  {
    "content": "Cookie consent\nWe use cookies to:\nAnonymously measure page views, and\nAllow you to give us one-click feedback on any page.\nWe do\nnot\ncollect or store:\nAny personally identifiable information.\nAny information for any (re)marketing purposes.\nWith your consent, you're helping us to make our documentation better 💙\nGoogle Analytics\nAccept\nReject\nManage settings",
    "metadata": {
      "source_url": "patterns_bulk_end-to-end.html",
      "source_type": "sdk",
      "file": "patterns_bulk_end-to-end.json",
      "chunk_id": 53
    }
  }
]