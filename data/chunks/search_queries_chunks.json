[
  {
    "content": "Querying overview - Developer\nSkip to content\nQuerying overview\nÂ¶\nThe query defines what you want to find in your search.\nAt the highest level, what is key to understand is the\ncontext\nof your query.\nQuery context\nÂ¶\nBy default, Elasticsearch sorts results by a\nrelevance score\n, which measures how well each document matches a query.\n1\nWhen you as a person are running a search through a UI this is fantastic â€” your results are presented back in a logical order even with some fuzziness applied to your search terms.\nThis works because queries calculate these scores to rank (sort) the results.\nQueries that calculate these scores run in\nquery context\n. They answer the question:\n\"How\nwell\ndoes this result match this query clause?\"\nFilter context\nÂ¶\nWhen we're talking about machines running searches, though, this kind of scoring and ranking is often unnecessary. In most cases, in your program you only want to know whether a result matches what you're looking for or not â€” a much more binary decision.\nQueries that include or exclude a result as a binary decision run in\nfilter context\n. They answer the question:\n\"Does this result match this query clause (yes or no)?\"",
    "metadata": {
      "source_url": "search_queries.html",
      "source_type": "sdk",
      "file": "search_queries.json",
      "chunk_id": 0
    }
  },
  {
    "content": "Queries that include or exclude a result as a binary decision run in\nfilter context\n. They answer the question:\n\"Does this result match this query clause (yes or no)?\"\nFilter context is therefore faster, and in addition is cached automatically by Elasticsearch.\nOur SDK interfaces use filter context exclusively\nSince programmatic searching rarely (if ever) needs relevance scoring, our SDKs use filter context exclusively. If you have a strong need for relevance scoring of your results when searching programmatically, please let us know your use case!\n1.0.0\n4.0.0\nWhat this means in practice:\nJava\nPython\nKotlin\nRaw REST API\nBuild the query and request\n1\n2\n3\n4\nIndexSearchRequest\nindex\n=\nTable\n.\nselect\n(\nclient\n)\n// (1)\n.\nwhere\n(\nTable\n.\nNAME\n.\nstartsWith\n(\n\"abc\"\n))\n// (2)\n.\nsort\n(\nTable\n.\nUPDATE_TIME\n.\norder\n(\nSortOrder\n.\nDesc\n))\n// (3)\n.\ntoRequest\n();\nStarting with the fluent search's\nselect()\nhelper will construct a query in the background that uses\nfilter\ns to narrow results by type (\nTable\nin this example) and to only active assets. Because this operation may retrieve information from Atlan, you must\nprovide it an\nAtlanClient\nthrough which to connect to the tenant.",
    "metadata": {
      "source_url": "search_queries.html",
      "source_type": "sdk",
      "file": "search_queries.json",
      "chunk_id": 1
    }
  },
  {
    "content": "Table\nin this example) and to only active assets. Because this operation may retrieve information from Atlan, you must\nprovide it an\nAtlanClient\nthrough which to connect to the tenant.\nAny other conditions you chain onto the query (through a\n.where()\n) will also be translated to\nfilter\ns.\nIf you are\nsorting\nby some property of the results anyway, like when they were last modified, you probably do not need a score for each result â€” so filters will be the more performant option.\nBuild the query and request\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\nfrom\npyatlan.model.enums\nimport\nSortOrder\nfrom\npyatlan.model.fluent_search\nimport\nCompoundQuery\n,\nFluentSearch\nfrom\npyatlan.model.assets\nimport\nTable\nindex\n=\n(\nFluentSearch\n()\n# (1)\n.\nwhere\n(\nCompoundQuery\n.\nasset_type\n(\nTable\n))\n# (2)\n.\nwhere\n(\nCompoundQuery\n.\nactive_assets\n())\n.\nwhere\n(\nTable\n.\nNAME\n.\nstartswith\n(\n\"abc\"\n))\n.\nsort\n(\nTable\n.\nUPDATE_TIME\n.\norder\n(\nSortOrder\n.\nDESCENDING\n))\n# (3)\n)\n.\nto_request\n()\nStarting with a\nFluentSearch()\nwill construct a query.\nEvery chained\n.where()\ncondition will be translated to a\nfilter\nin Elastic.\nIf you are\nsorting",
    "metadata": {
      "source_url": "search_queries.html",
      "source_type": "sdk",
      "file": "search_queries.json",
      "chunk_id": 2
    }
  },
  {
    "content": "SortOrder\n.\nDESCENDING\n))\n# (3)\n)\n.\nto_request\n()\nStarting with a\nFluentSearch()\nwill construct a query.\nEvery chained\n.where()\ncondition will be translated to a\nfilter\nin Elastic.\nIf you are\nsorting\nby some property of the results anyway, like when they were last modified, you probably do not need a score for each result â€” so filters will be the more performant option.\nBuild the query and request\n1\n2\n3\n4\nval\nindex\n=\nTable\n.\nselect\n(\ntrue\n)\n// (1)\n.\nwhere\n(\nTable\n.\nNAME\n.\nstartsWith\n(\n\"abc\"\n))\n// (2)\n.\nsort\n(\nTable\n.\nUPDATE_TIME\n.\norder\n(\nSortOrder\n.\nDesc\n))\n// (3)\n.\ntoRequest\n()\nStarting with the fluent search's\nselect()\nhelper will construct a query in the background that uses\nfilter\ns to narrow results by type (\nTable\nin this example) and to only active assets. Because this operation may retrieve information from Atlan, you must\nprovide it an\nAtlanClient\nthrough which to connect to the tenant.\nAny other conditions you chain onto the query (through a\n.where()\n) will also be translated to\nfilter\ns.\nIf you are\nsorting",
    "metadata": {
      "source_url": "search_queries.html",
      "source_type": "sdk",
      "file": "search_queries.json",
      "chunk_id": 3
    }
  },
  {
    "content": "provide it an\nAtlanClient\nthrough which to connect to the tenant.\nAny other conditions you chain onto the query (through a\n.where()\n) will also be translated to\nfilter\ns.\nIf you are\nsorting\nby some property of the results anyway, like when they were last modified, you probably do not need a score for each result â€” so filters will be the more performant option.\nPOST /api/meta/search/indexsearch\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n{\n\"dsl\"\n:\n{\n\"query\"\n:\n{\n// (1)\n\"bool\"\n:\n{\n\"filter\"\n:\n[\n// (2)\n{\n\"term\"\n:\n{\n\"__typeName.keyword\"\n:\n\"Table\"\n}}\n]\n}\n},\n\"sort\"\n:\n[\n// (3)\n{\n\"__modificationTimestamp\"\n:\n{\n\"order\"\n:\n\"desc\"\n}}\n]\n}\n}\nAlthough we use a query construct (which we must to get any results)...\n...if we are looking for exact matches only (and don't care about scoring), then we should put our search requirements into a\nfilter\n.\nThis is particularly true if we are\nsorting\nby some property of the results anyway, like when they were last modified.\nThis page is a summary of the details in the Elasticsearch Guide's\nQuery and filter context\nâ†©\n2022-09-08\n2025-01-16\nWas this page helpful?\nThanks for your feedback!\nThanks for your feedback! Help us improve this page by using our\nfeedback form",
    "metadata": {
      "source_url": "search_queries.html",
      "source_type": "sdk",
      "file": "search_queries.json",
      "chunk_id": 4
    }
  },
  {
    "content": "Query and filter context\nâ†©\n2022-09-08\n2025-01-16\nWas this page helpful?\nThanks for your feedback!\nThanks for your feedback! Help us improve this page by using our\nfeedback form\nto provide us with more information.\nBack to top\nCookie consent\nWe use cookies to:\nAnonymously measure page views, and\nAllow you to give us one-click feedback on any page.\nWe do\nnot\ncollect or store:\nAny personally identifiable information.\nAny information for any (re)marketing purposes.\nWith your consent, you're helping us to make our documentation better ðŸ’™\nGoogle Analytics\nAccept\nReject\nManage settings",
    "metadata": {
      "source_url": "search_queries.html",
      "source_type": "sdk",
      "file": "search_queries.json",
      "chunk_id": 5
    }
  }
]