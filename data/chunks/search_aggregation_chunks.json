[
  {
    "content": "Aggregating search results - Developer\nSkip to content\nAggregating search results\n¶\nYou can aggregate information about your search results in a few ways.\nCurrently only the following are implemented through the SDKs, though Elasticsearch itself supports many additional scenarios\n1\n.\nBucket aggregation\n¶\nYou can group results together based on a field using bucket aggregation. With this, you can answer questions like:\nWhich kinds of assets most frequently match my search criteria?\n1.4.0\n4.0.0\nFor example:\nJava\nPython\nKotlin\nRaw REST API\nBuild a bucket aggregation\n1\n2\n3\n4\n5\nIndexSearchRequest\nrequest\n=\nclient\n.\nassets\n.\nselect\n()\n// (1)\n.\naggregate\n(\n\"type\"\n,\nAsset\n.\nTYPE_NAME\n.\nbucketBy\n())\n// (2)\n.\nsort\n(\nAsset\n.\nCREATE_TIME\n.\norder\n(\nSortOrder\n.\nDesc\n))\n.\ntoRequest\n();\n// (3)\nIndexSearchResponse\nresponse\n=\nrequest\n.\nsearch\n(\nclient\n);\n// (4)\nStart building a query from a client, using its 'assets' member's\nselect()\nmethod.\nAdd an aggregation by chaining one or more\naggregate()\nmethods, and passing:",
    "metadata": {
      "source_url": "search_aggregation.html",
      "source_type": "sdk",
      "file": "search_aggregation.json",
      "chunk_id": 0
    }
  },
  {
    "content": "=\nrequest\n.\nsearch\n(\nclient\n);\n// (4)\nStart building a query from a client, using its 'assets' member's\nselect()\nmethod.\nAdd an aggregation by chaining one or more\naggregate()\nmethods, and passing:\nAny arbitrary key you want, which you'll use to look up the results of the aggregation in the response. You can add as many aggregations as you want, but each must have a unique key to look up its unique results.\nThe field you want to aggregate, along with the kind of aggregation you want to do on that field. This example will bucket the results based on the distinct types of assets (tables, columns, etc).\nYou can then turn these criteria into a search request using the\ntoRequest()\nhelper.\nAnd once you have a request, you can then run the search. Because this operation will retrieve information from Atlan, you must\nprovide it an\nAtlanClient\nthrough which to connect to the tenant.\nDo something with the results\n6\n7\n8\n9\n10\n11\n12\nMap\n<\nString\n,\nAggregationResult\n>\naggregates\n=\nresponse\n.\ngetAggregations\n();\n// (1)\nAggregationBucketResult\nresult\n=\n(\nAggregationBucketResult\n)\naggregates\n.\nget\n(\n\"type\"\n);\n// (2)\nList\n<\nAggregationBucketDetails\n>\nbuckets\n=\nresult\n.\ngetBuckets\n();\n// (3)\nfor\n(",
    "metadata": {
      "source_url": "search_aggregation.html",
      "source_type": "sdk",
      "file": "search_aggregation.json",
      "chunk_id": 1
    }
  },
  {
    "content": "();\n// (1)\nAggregationBucketResult\nresult\n=\n(\nAggregationBucketResult\n)\naggregates\n.\nget\n(\n\"type\"\n);\n// (2)\nList\n<\nAggregationBucketDetails\n>\nbuckets\n=\nresult\n.\ngetBuckets\n();\n// (3)\nfor\n(\nAggregationBucketDetails\ndetail\n:\nbuckets\n)\n{\n// (4)\ndetail\n.\ngetKey\n();\n// (5)\ndetail\n.\ngetDocCount\n();\n// (6)\n}\nFrom the search response, not only can you retrieve the results (as in previous examples), but when an aggregation is requested you can also retrieve the aggregation result.\nSince multiple aggregations can be requested, you can retrieve a specific aggregation result by name. (You would probably want to type-check this before the explicit cast.)\nIf the result is to a request that produces aggregation buckets, there will be bucket-specific details within it.\nYou can iterate through these details...\n...to retrieve the key of the bucket (in the example this would be the type of asset: table, column, etc).\n...to retrieve the number of results that match that bucket key (in the example, how many tables, columns, etc there are in the results).\nBuild a bucket aggregation\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\nfrom\npyatlan.client.atlan\nimport\nAtlanClient\nfrom\npyatlan.model.assets\nimport\nAsset\nfrom",
    "metadata": {
      "source_url": "search_aggregation.html",
      "source_type": "sdk",
      "file": "search_aggregation.json",
      "chunk_id": 2
    }
  },
  {
    "content": "Build a bucket aggregation\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\nfrom\npyatlan.client.atlan\nimport\nAtlanClient\nfrom\npyatlan.model.assets\nimport\nAsset\nfrom\npyatlan.model.fluent_search\nimport\nFluentSearch\nclient\n=\nAtlanClient\n()\nrequest\n=\n(\nFluentSearch\n.\nselect\n()\n# (1)\n.\naggregate\n(\n\"type\"\n,\nAsset\n.\nTYPE_NAME\n.\nbucket_by\n())\n# (2)\n.\nsort\n(\nAsset\n.\nCREATE_TIME\n.\norder\n())\n)\n.\nto_request\n()\n# (3)\nresults\n=\nclient\n.\nasset\n.\nsearch\n(\ncriteria\n=\nrequest\n)\n# (4)\nStart building a query from a FluentSearch, using its\nselect()\nmethod.\nAdd an aggregation by chaining one or more\naggregate()\nmethods, and passing:\nAny arbitrary key you want, which you'll use to look up the results of the aggregation in the response. You can add as many aggregations as you want, but each must have a unique key to look up its unique results.\nThe field you want to aggregate, along with the kind of aggregation you want to do on that field. This example will bucket the results based on the distinct types of assets (tables, columns, etc).\nYou can then turn these criteria into a search request using the\nto_request()\nhelper.\nAnd once you have a request, you can then run the search.\nDo something with the results\n12\n13\n14\n15\n16\nresult",
    "metadata": {
      "source_url": "search_aggregation.html",
      "source_type": "sdk",
      "file": "search_aggregation.json",
      "chunk_id": 3
    }
  },
  {
    "content": "You can then turn these criteria into a search request using the\nto_request()\nhelper.\nAnd once you have a request, you can then run the search.\nDo something with the results\n12\n13\n14\n15\n16\nresult\n=\nresults\n.\naggregations\n[\n\"type\"\n]\n# (1)\nbuckets\n=\nresult\n.\nbuckets\n:\n# (2)\nfor\ndetail\nin\nbuckets\n:\n# (3)\ndetail\n.\nkey\n# (4)\ndetail\n.\ndoc_count\n# (5)\nSince multiple aggregations can be requested, you can retrieve a specific aggregation result by name.\nIf the result is to a request that produces aggregation buckets, there will be bucket-specific details within it.\nYou can iterate through these details...\n...to retrieve the key of the bucket (in the example this would be the type of asset: table, column, etc).\n...to retrieve the number of results that match that bucket key (in the example, how many tables, columns, etc there are in the results).\nBuild a bucket aggregation\n1\n2\n3\n4\n5\nval\nrequest\n=\nclient\n.\nassets\n.\nselect\n()\n// (1)\n.\naggregate\n(\n\"type\"\n,\nAsset\n.\nTYPE_NAME\n.\nbucketBy\n())\n// (2)\n.\nsort\n(\nAsset\n.\nCREATE_TIME\n.\norder\n(\nSortOrder\n.\nDesc\n))\n.\ntoRequest\n()\n// (3)\nval\nresponse\n=\nrequest\n.\nsearch\n(\nclient\n)\n// (4)\nStart building a query from a client, using its 'assets' member's",
    "metadata": {
      "source_url": "search_aggregation.html",
      "source_type": "sdk",
      "file": "search_aggregation.json",
      "chunk_id": 4
    }
  },
  {
    "content": ".\nsort\n(\nAsset\n.\nCREATE_TIME\n.\norder\n(\nSortOrder\n.\nDesc\n))\n.\ntoRequest\n()\n// (3)\nval\nresponse\n=\nrequest\n.\nsearch\n(\nclient\n)\n// (4)\nStart building a query from a client, using its 'assets' member's\nselect()\nmethod.\nAdd an aggregation by chaining one or more\naggregate()\nmethods, and passing:\nAny arbitrary key you want, which you'll use to look up the results of the aggregation in the response. You can add as many aggregations as you want, but each must have a unique key to look up its unique results.\nThe field you want to aggregate, along with the kind of aggregation you want to do on that field. This example will bucket the results based on the distinct types of assets (tables, columns, etc).\nYou can then turn these criteria into a search request using the\ntoRequest()\nhelper.\nAnd once you have a request, you can then run the search. Because this operation will retrieve information from Atlan, you must\nprovide it an\nAtlanClient\nthrough which to connect to the tenant.\nDo something with the results\n6\n7\n8\n9\n10\n11\n12\nval\naggregates\n=\nresponse\n.\naggregations\n// (1)\nval\nresult\n=\naggregates\n[\n\"type\"\n]\nas\nAggregationBucketResult\n// (2)\nval\nbuckets\n=\nresult\n.\nbuckets\n// (3)\nfor\n(\ndetail\nin",
    "metadata": {
      "source_url": "search_aggregation.html",
      "source_type": "sdk",
      "file": "search_aggregation.json",
      "chunk_id": 5
    }
  },
  {
    "content": "6\n7\n8\n9\n10\n11\n12\nval\naggregates\n=\nresponse\n.\naggregations\n// (1)\nval\nresult\n=\naggregates\n[\n\"type\"\n]\nas\nAggregationBucketResult\n// (2)\nval\nbuckets\n=\nresult\n.\nbuckets\n// (3)\nfor\n(\ndetail\nin\nbuckets\n)\n{\n// (4)\ndetail\n.\nkey\n// (5)\ndetail\n.\ndocCount\n// (6)\n}\nFrom the search response, not only can you retrieve the results (as in previous examples), but when an aggregation is requested you can also retrieve the aggregation result.\nSince multiple aggregations can be requested, you can retrieve a specific aggregation result by name. (You would probably want to type-check this before the explicit cast.)\nIf the result is to a request that produces aggregation buckets, there will be bucket-specific details within it.\nYou can iterate through these details...\n...to retrieve the key of the bucket (in the example this would be the type of asset: table, column, etc).\n...to retrieve the number of results that match that bucket key (in the example, how many tables, columns, etc there are in the results).\nPOST /api/meta/search/indexsearch\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n{\n\"dsl\"\n:\n{\n\"aggregations\"\n:\n{\n// (1)\n\"type\"\n:\n{\n\"terms\"\n:\n{\n\"field\"\n:\n\"__typeName.keyword\"\n}\n}\n}\n\"query\"\n:\n{",
    "metadata": {
      "source_url": "search_aggregation.html",
      "source_type": "sdk",
      "file": "search_aggregation.json",
      "chunk_id": 6
    }
  },
  {
    "content": "POST /api/meta/search/indexsearch\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n{\n\"dsl\"\n:\n{\n\"aggregations\"\n:\n{\n// (1)\n\"type\"\n:\n{\n\"terms\"\n:\n{\n\"field\"\n:\n\"__typeName.keyword\"\n}\n}\n}\n\"query\"\n:\n{\n\"bool\"\n:\n{\n\"filter\"\n:\n[\n{\n\"term\"\n:\n{\n\"__typeName.keyword\"\n:\n\"Table\"\n}}\n]\n}\n},\n\"sort\"\n:\n[\n{\n\"__modificationTimestamp\"\n:\n{\n\"order\"\n:\n\"desc\"\n}}\n]\n}\n}\nAdd an aggregation to your search. You can add multiple aggregations to a single search, but each must have a unique name (\ntype\nin this example is such a name).\nMetric aggregation\n¶\nYou can also calculate metrics about your search results. With this, you can answer questions like:\nWhat is the average number of columns I have in tables and views in a particular schema?\n1.4.0\n4.0.0\nFor example:\nJava\nPython\nKotlin\nRaw REST API\nBuild a metric aggregation\n1\n2\n3\n4\n5\nIndexSearchRequest\nrequest\n=\nclient\n.\nassets\n.\nselect\n()\n// (1)\n.\naggregate\n(\n\"avg_columns\"\n,\nTable\n.\nCOLUMN_COUNT\n.\navg\n())\n// (2)\n.\nsort\n(\nAsset\n.\nCREATE_TIME\n.\norder\n(\nSortOrder\n.\nDesc\n))\n.\ntoRequest\n();\n// (3)\nIndexSearchResponse\nresponse\n=\nrequest\n.\nsearch\n(\nclient\n);\n// (4)\nStart building a query from a client, using its 'assets' member's\nselect()\nmethod.",
    "metadata": {
      "source_url": "search_aggregation.html",
      "source_type": "sdk",
      "file": "search_aggregation.json",
      "chunk_id": 7
    }
  },
  {
    "content": "(\nSortOrder\n.\nDesc\n))\n.\ntoRequest\n();\n// (3)\nIndexSearchResponse\nresponse\n=\nrequest\n.\nsearch\n(\nclient\n);\n// (4)\nStart building a query from a client, using its 'assets' member's\nselect()\nmethod.\nAdd an aggregation by chaining one or more\naggregate()\nmethods, and passing:\nAny arbitrary key you want, which you'll use to look up the results of the aggregation in the response. You can add as many aggregations as you want, but each must have a unique key to look up its unique results.\nThe field you want to aggregate, along with the kind of aggregation you want to do on that field. This example will calculate an average of numeric values across the results (in this case, column counts on tables).\nYou can then turn these criteria into a search request using the\ntoRequest()\nhelper.\nAnd once you have a request, you can then run the search. Because this operation will retrieve information from Atlan, you must\nprovide it an\nAtlanClient\nthrough which to connect to the tenant.\nDo something with the results\n6\n7\n8\nMap\n<\nString\n,\nAggregationResult\n>\naggregates\n=\nresponse\n.\ngetAggregations\n();\n// (1)\nAggregationMetricResult\nresult\n=\n(\nAggregationMetricResult\n)\naggregates\n.\nget\n(\n\"avg_columns\"\n);",
    "metadata": {
      "source_url": "search_aggregation.html",
      "source_type": "sdk",
      "file": "search_aggregation.json",
      "chunk_id": 8
    }
  },
  {
    "content": "6\n7\n8\nMap\n<\nString\n,\nAggregationResult\n>\naggregates\n=\nresponse\n.\ngetAggregations\n();\n// (1)\nAggregationMetricResult\nresult\n=\n(\nAggregationMetricResult\n)\naggregates\n.\nget\n(\n\"avg_columns\"\n);\n// (2)\nresult\n.\ngetValue\n();\n// (3)\nFrom the search response, not only can you retrieve the results (as in previous examples), but when an aggregation is requested you can also retrieve the aggregation result.\nSince multiple aggregations can be requested, you can retrieve a specific aggregation result by name. (You would probably want to type-check this before the explicit cast.)\nIf the result is to a request that produces an aggregation metric, you can retrieve the value of that calculated metric directly.\nBuild a metric aggregation\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\nfrom\npyatlan.client.atlan\nimport\nAtlanClient\nfrom\npyatlan.model.assets\nimport\nAsset\n,\nTable\nfrom\npyatlan.model.fluent_search\nimport\nFluentSearch\nclient\n=\nAtlanClient\n()\nrequest\n=\n(\nFluentSearch\n.\nselect\n()\n# (1)\n.\naggregate\n(\n\"avg_columns\"\n,\nTable\n.\nCOLUMN_COUNT\n.\navg\n())\n# (2)\n.\nsort\n(\nAsset\n.\nCREATE_TIME\n.\norder\n())\n)\n.\nto_request\n()\n# (3)\nresults\n=\nclient\n.\nasset\n.\nsearch\n(\ncriteria\n=\nrequest\n)",
    "metadata": {
      "source_url": "search_aggregation.html",
      "source_type": "sdk",
      "file": "search_aggregation.json",
      "chunk_id": 9
    }
  },
  {
    "content": "()\n# (1)\n.\naggregate\n(\n\"avg_columns\"\n,\nTable\n.\nCOLUMN_COUNT\n.\navg\n())\n# (2)\n.\nsort\n(\nAsset\n.\nCREATE_TIME\n.\norder\n())\n)\n.\nto_request\n()\n# (3)\nresults\n=\nclient\n.\nasset\n.\nsearch\n(\ncriteria\n=\nrequest\n)\nStart building a query from the FluentSearch, using its\nselect()\nmethod.\nAdd an aggregation by chaining one or more\naggregate()\nmethods, and passing:\nAny arbitrary key you want, which you'll use to look up the results of the aggregation in the response. You can add as many aggregations as you want, but each must have a unique key to look up its unique results.\nThe field you want to aggregate, along with the kind of aggregation you want to do on that field. This example will calculate an average of numeric values across the results (in this case, column counts on tables).\nYou can then turn these criteria into a search request using the\nto_request()\nhelper.\nDo something with the results\n13\n14\nresult\n=\nresults\n.\naggregations\n[\n'avg_columns'\n]\n# (1)\nresult\n.\nvalue\n# (2)\nSince multiple aggregations can be requested, you can retrieve a specific aggregation result by name.",
    "metadata": {
      "source_url": "search_aggregation.html",
      "source_type": "sdk",
      "file": "search_aggregation.json",
      "chunk_id": 10
    }
  },
  {
    "content": "13\n14\nresult\n=\nresults\n.\naggregations\n[\n'avg_columns'\n]\n# (1)\nresult\n.\nvalue\n# (2)\nSince multiple aggregations can be requested, you can retrieve a specific aggregation result by name.\nIf the result is to a request that produces an aggregation metric, you can retrieve the value of that calculated metric directly.\nBuild a metric aggregation\n1\n2\n3\n4\n5\nval\nrequest\n=\nclient\n.\nassets\n.\nselect\n()\n// (1)\n.\naggregate\n(\n\"avg_columns\"\n,\nTable\n.\nCOLUMN_COUNT\n.\navg\n())\n// (2)\n.\nsort\n(\nAsset\n.\nCREATE_TIME\n.\norder\n(\nSortOrder\n.\nDesc\n))\n.\ntoRequest\n()\n// (3)\nval\nresponse\n=\nrequest\n.\nsearch\n(\nclient\n)\n// (4)\nStart building a query from a client, using its 'assets' member's\nselect()\nmethod.\nAdd an aggregation by chaining one or more\naggregate()\nmethods, and passing:\nAny arbitrary key you want, which you'll use to look up the results of the aggregation in the response. You can add as many aggregations as you want, but each must have a unique key to look up its unique results.\nThe field you want to aggregate, along with the kind of aggregation you want to do on that field. This example will calculate an average of numeric values across the results (in this case, column counts on tables).",
    "metadata": {
      "source_url": "search_aggregation.html",
      "source_type": "sdk",
      "file": "search_aggregation.json",
      "chunk_id": 11
    }
  },
  {
    "content": "You can then turn these criteria into a search request using the\ntoRequest()\nhelper.\nAnd once you have a request, you can then run the search. Because this operation will retrieve information from Atlan, you must\nprovide it an\nAtlanClient\nthrough which to connect to the tenant.\nDo something with the results\n6\n7\n8\nval\naggregates\n=\nresponse\n.\naggregations\n// (1)\nval\nresult\n=\naggregates\n[\n\"avg_columns\"\n]\nas\nAggregationMetricResult\n// (2)\nresult\n.\nvalue\n// (3)\nFrom the search response, not only can you retrieve the results (as in previous examples), but when an aggregation is requested you can also retrieve the aggregation result.\nSince multiple aggregations can be requested, you can retrieve a specific aggregation result by name. (You would probably want to type-check this before the explicit cast.)\nIf the result is to a request that produces an aggregation metric, you can retrieve the value of that calculated metric directly.\nPOST /api/meta/search/indexsearch\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n{\n\"dsl\"\n:\n{\n\"aggregations\"\n:\n{\n// (1)\n\"avg_columns\"\n:\n{\n\"avg\"\n:\n{\n\"field\"\n:\n\"columnCount\"\n}\n}\n}\n\"query\"\n:\n{\n\"bool\"\n:\n{\n\"filter\"\n:\n[\n{\n\"term\"\n:\n{\n\"__typeName.keyword\"\n:",
    "metadata": {
      "source_url": "search_aggregation.html",
      "source_type": "sdk",
      "file": "search_aggregation.json",
      "chunk_id": 12
    }
  },
  {
    "content": "12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n{\n\"dsl\"\n:\n{\n\"aggregations\"\n:\n{\n// (1)\n\"avg_columns\"\n:\n{\n\"avg\"\n:\n{\n\"field\"\n:\n\"columnCount\"\n}\n}\n}\n\"query\"\n:\n{\n\"bool\"\n:\n{\n\"filter\"\n:\n[\n{\n\"term\"\n:\n{\n\"__typeName.keyword\"\n:\n\"Table\"\n}}\n]\n}\n},\n\"sort\"\n:\n[\n{\n\"__modificationTimestamp\"\n:\n{\n\"order\"\n:\n\"desc\"\n}}\n]\n}\n}\nAdd an aggregation to your search. You can add multiple aggregations to a single search, but each must have a unique name (\navg_columns\nin this example is such a name).\nThis page is a summary of the details in the Elasticsearch Guide's\naggregation guide\n↩\n2022-09-09\n2025-01-16\nWas this page helpful?\nThanks for your feedback!\nThanks for your feedback! Help us improve this page by using our\nfeedback form\nto provide us with more information.\nBack to top\nCookie consent\nWe use cookies to:\nAnonymously measure page views, and\nAllow you to give us one-click feedback on any page.\nWe do\nnot\ncollect or store:\nAny personally identifiable information.\nAny information for any (re)marketing purposes.\nWith your consent, you're helping us to make our documentation better 💙\nGoogle Analytics\nAccept\nReject\nManage settings",
    "metadata": {
      "source_url": "search_aggregation.html",
      "source_type": "sdk",
      "file": "search_aggregation.json",
      "chunk_id": 13
    }
  }
]